<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.7">
  <compounddef id="class_sampling_1_1_volume" kind="class" prot="public" abstract="yes">
    <compoundname>Sampling::Volume</compoundname>
    <basecompoundref refid="class_sampling_1_1_i_sampleable" prot="public" virt="non-virtual">Sampling::ISampleable&lt; T &gt;</basecompoundref>
    <basecompoundref refid="class_geometry_1_1_surface" prot="public" virt="non-virtual">Geometry::Surface&lt; T &gt;</basecompoundref>
    <derivedcompoundref refid="class_sampling_1_1_filter" prot="public" virt="non-virtual">Filter&lt; T &gt;</derivedcompoundref>
    <derivedcompoundref refid="class_sampling_1_1_marschner_lobb" prot="public" virt="non-virtual">MarschnerLobb&lt; T &gt;</derivedcompoundref>
    <includes refid="_volume_8h" local="no">Volume.h</includes>
    <templateparamlist>
      <param>
        <type>typename</type>
        <declname>T</declname>
        <defname>T</defname>
      </param>
    </templateparamlist>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="class_sampling_1_1_volume_1a8c8c997c19f49d10d5028ecd6d94805c" prot="protected" static="no" mutable="no">
        <type>T</type>
        <definition>T iso</definition>
        <argsstring></argsstring>
        <name>iso</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" line="26" column="1" bodyfile="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" bodystart="26" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-func">
      <memberdef kind="function" id="class_sampling_1_1_volume_1a3a8fada6f2d2b5ce58f6a0ffef34d9f1" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Volume</definition>
        <argsstring>()</argsstring>
        <name>Volume</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>default c&apos;tor </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" line="31" column="1" bodyfile="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" bodystart="98" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="class_sampling_1_1_volume_1aefc1e3fc5f3846e8a1f3186e06017b52" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>Volume</definition>
        <argsstring>(const T &amp;iso, const Material *material=0)</argsstring>
        <name>Volume</name>
        <param>
          <type>const T &amp;</type>
          <declname>iso</declname>
        </param>
        <param>
          <type>const <ref refid="struct_visualisation_1_1_material" kindref="compound">Material</ref> *</type>
          <declname>material</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>c&apos;tor with argument <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iso</parametername>
</parameternamelist>
<parameterdescription>
<para>- the albedo value for the volume </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>material</parametername>
</parameternamelist>
<parameterdescription>
<para>- the material of the isosurfaces of the volume (given for visualisation purposes) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" line="39" column="1" bodyfile="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" bodystart="103" bodyend="106"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="class_sampling_1_1_volume_1af98bbc751e90a15b59c81ee4c17630b2" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>T</type>
        <definition>T getIso</definition>
        <argsstring>() const </argsstring>
        <name>getIso</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Getter function for the albedo value for the volume. <simplesect kind="return"><para>- the albedo value for the volume </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" line="49" column="1" bodyfile="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" bodystart="110" bodyend="113"/>
      </memberdef>
      <memberdef kind="function" id="class_sampling_1_1_volume_1a06df2552be7fe124a173741e8ba79770" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void setIso</definition>
        <argsstring>(const T &amp;iso)</argsstring>
        <name>setIso</name>
        <param>
          <type>const T &amp;</type>
          <declname>iso</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Setter function for the albedo value for the volume. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iso</parametername>
</parameternamelist>
<parameterdescription>
<para>- the new albedo value for the volume </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" line="55" column="1" bodyfile="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" bodystart="117" bodyend="120"/>
      </memberdef>
      <memberdef kind="function" id="class_sampling_1_1_volume_1aaf6cee9a80b3085218861a5a8d6b34bc" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>T</type>
        <definition>virtual T getValueAt</definition>
        <argsstring>(const Vector&lt; T &gt; &amp;point, const Utilities::TypeOperators&lt; T &gt; &amp;Toperators) const =0</argsstring>
        <name>getValueAt</name>
        <reimplements refid="class_sampling_1_1_i_sampleable_1aaf6cee9a80b3085218861a5a8d6b34bc">getValueAt</reimplements>
        <reimplementedby refid="class_sampling_1_1_linear_cube_filter_1ae7fe064de3b279d74867a690bd6f4953">getValueAt</reimplementedby>
        <reimplementedby refid="class_sampling_1_1_linear_tetra_filter_1ae7fe064de3b279d74867a690bd6f4953">getValueAt</reimplementedby>
        <reimplementedby refid="class_sampling_1_1_marschner_lobb_1ae7fe064de3b279d74867a690bd6f4953">getValueAt</reimplementedby>
        <reimplementedby refid="class_sampling_1_1_filter_1aaf6cee9a80b3085218861a5a8d6b34bc">getValueAt</reimplementedby>
        <param>
          <type>const <ref refid="class_geometry_1_1_vector" kindref="compound">Vector</ref>&lt; T &gt; &amp;</type>
          <declname>point</declname>
        </param>
        <param>
          <type>const <ref refid="class_utilities_1_1_type_operators" kindref="compound">Utilities::TypeOperators</ref>&lt; T &gt; &amp;</type>
          <declname>Toperators</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function that calculates the value of the sampleable object at the position specified by the argument &apos;point&apos;. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>point</parametername>
</parameternamelist>
<parameterdescription>
<para>- the point where the object must calculate the return value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Toperators</parametername>
</parameternamelist>
<parameterdescription>
<para>- the operators object of type T </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>- the value at the given point </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" line="67" column="1"/>
      </memberdef>
      <memberdef kind="function" id="class_sampling_1_1_volume_1af9134066dc508e3201a1dea2acb755a8" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="class_geometry_1_1_vector" kindref="compound">Vector</ref>&lt; T &gt;</type>
        <definition>Vector&lt; T &gt; getNormal</definition>
        <argsstring>(Vector&lt; T &gt; point, const T &amp;scale, T value=T(), const Utilities::TypeOperators&lt; T &gt; &amp;Toperators=Utilities::TypeOperators&lt; T &gt;()) const </argsstring>
        <name>getNormal</name>
        <reimplements refid="class_geometry_1_1_surface_1a9f3f940415136a6c508a0d9de1683adb">getNormal</reimplements>
        <param>
          <type><ref refid="class_geometry_1_1_vector" kindref="compound">Vector</ref>&lt; T &gt;</type>
          <declname>point</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>scale</declname>
        </param>
        <param>
          <type>T</type>
          <declname>value</declname>
          <defval>T()</defval>
        </param>
        <param>
          <type>const <ref refid="class_utilities_1_1_type_operators" kindref="compound">Utilities::TypeOperators</ref>&lt; T &gt; &amp;</type>
          <declname>Toperators</declname>
          <defval><ref refid="class_utilities_1_1_type_operators" kindref="compound">Utilities::TypeOperators</ref>&lt; T &gt;()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function that can approximate a normal vector to the surface at a given point. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>point</parametername>
</parameternamelist>
<parameterdescription>
<para>- the point whose normal vector we are interested </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scale</parametername>
</parameternamelist>
<parameterdescription>
<para>- the scale parameter defines the distance from point in each dimension to build the gradient vector </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>- the value at the point won&apos;t be recomputed, if it&apos;s given in this parameter </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Toperators</parametername>
</parameternamelist>
<parameterdescription>
<para>- the operators object of type T </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" line="78" column="1" bodyfile="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" bodystart="123" bodyend="140"/>
      </memberdef>
      <memberdef kind="function" id="class_sampling_1_1_volume_1aae711dcbf18946964b9c42502e9d3377" prot="public" static="no" const="yes" explicit="no" inline="no" virt="virtual">
        <type><ref refid="class_geometry_1_1_vector" kindref="compound">Vector</ref>&lt; <ref refid="struct_geometry_1_1_intersection" kindref="compound">Intersection</ref>&lt; T &gt; &gt;</type>
        <definition>Vector&lt; Intersection&lt; T &gt; &gt; intersect</definition>
        <argsstring>(const Ray&lt; T &gt; &amp;ray, const Vector&lt; Intersection&lt; T &gt;&gt; *bounds=0, const T &amp;scale=T(), const Utilities::TypeOperators&lt; T &gt; &amp;Toperators=Utilities::TypeOperators&lt; T &gt;()) const </argsstring>
        <name>intersect</name>
        <reimplements refid="class_geometry_1_1_surface_1ab7b27cca569f9eae8628dd93e54c2d3e">intersect</reimplements>
        <param>
          <type>const <ref refid="class_geometry_1_1_ray" kindref="compound">Ray</ref>&lt; T &gt; &amp;</type>
          <declname>ray</declname>
        </param>
        <param>
          <type>const <ref refid="class_geometry_1_1_vector" kindref="compound">Vector</ref>&lt; <ref refid="struct_geometry_1_1_intersection" kindref="compound">Intersection</ref>&lt; T &gt;&gt; *</type>
          <declname>bounds</declname>
          <defval>0</defval>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>scale</declname>
          <defval>T()</defval>
        </param>
        <param>
          <type>const <ref refid="class_utilities_1_1_type_operators" kindref="compound">Utilities::TypeOperators</ref>&lt; T &gt; &amp;</type>
          <declname>Toperators</declname>
          <defval><ref refid="class_utilities_1_1_type_operators" kindref="compound">Utilities::TypeOperators</ref>&lt; T &gt;()</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Function that implements the intersection with the concrete object. If no intersection was found, it will return an empty Vector. (0D Vector) <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ray</parametername>
</parameternamelist>
<parameterdescription>
<para>- the intersection ray </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bounds</parametername>
</parameternamelist>
<parameterdescription>
<para>- the bounds between the intersection will be looked for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scale</parametername>
</parameternamelist>
<parameterdescription>
<para>- scale used by ray casting algorithms </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Toperators</parametername>
</parameternamelist>
<parameterdescription>
<para>- the operators object of type T </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>- The collection of intersections in ascending order of dimension time. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" line="91" column="1" bodyfile="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" bodystart="143" bodyend="167"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>This abstract class represents some volumetric data, which can be sampled and filtered. It can be an analytic function, or any other volumetric data set. </para>    </detaileddescription>
    <inheritancegraph>
      <node id="204">
        <label>Volume&lt; T &gt;</label>
        <link refid="class_sampling_1_1_volume"/>
        <childnode refid="205" relation="public-inheritance">
        </childnode>
        <childnode refid="206" relation="public-inheritance">
        </childnode>
      </node>
      <node id="210">
        <label>LinearTetraFilter&lt; T &gt;</label>
        <link refid="class_sampling_1_1_linear_tetra_filter"/>
        <childnode refid="208" relation="public-inheritance">
        </childnode>
      </node>
      <node id="209">
        <label>LinearCubeFilter&lt; T &gt;</label>
        <link refid="class_sampling_1_1_linear_cube_filter"/>
        <childnode refid="208" relation="public-inheritance">
        </childnode>
      </node>
      <node id="205">
        <label>ISampleable&lt; T &gt;</label>
        <link refid="class_sampling_1_1_i_sampleable"/>
      </node>
      <node id="206">
        <label>Surface&lt; T &gt;</label>
        <link refid="class_geometry_1_1_surface"/>
        <childnode refid="207" relation="public-inheritance">
        </childnode>
      </node>
      <node id="208">
        <label>Filter&lt; T &gt;</label>
        <link refid="class_sampling_1_1_filter"/>
        <childnode refid="204" relation="public-inheritance">
        </childnode>
      </node>
      <node id="211">
        <label>MarschnerLobb&lt; T &gt;</label>
        <link refid="class_sampling_1_1_marschner_lobb"/>
        <childnode refid="204" relation="public-inheritance">
        </childnode>
      </node>
      <node id="207">
        <label>IIntersectable&lt; T &gt;</label>
        <link refid="class_geometry_1_1_i_intersectable"/>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="218">
        <label>Point&lt; float &gt;</label>
        <link refid="class_geometry_1_1_point"/>
        <childnode refid="219" relation="public-inheritance">
        </childnode>
      </node>
      <node id="212">
        <label>Volume&lt; T &gt;</label>
        <link refid="class_sampling_1_1_volume"/>
        <childnode refid="213" relation="public-inheritance">
        </childnode>
        <childnode refid="214" relation="public-inheritance">
        </childnode>
      </node>
      <node id="216">
        <label>Material</label>
        <link refid="struct_visualisation_1_1_material"/>
        <childnode refid="217" relation="usage">
          <edgelabel>ka</edgelabel>
          <edgelabel>ks</edgelabel>
          <edgelabel>kd</edgelabel>
        </childnode>
      </node>
      <node id="213">
        <label>ISampleable&lt; T &gt;</label>
        <link refid="class_sampling_1_1_i_sampleable"/>
      </node>
      <node id="214">
        <label>Surface&lt; T &gt;</label>
        <link refid="class_geometry_1_1_surface"/>
        <childnode refid="215" relation="public-inheritance">
        </childnode>
        <childnode refid="216" relation="usage">
          <edgelabel>material</edgelabel>
        </childnode>
      </node>
      <node id="219">
        <label>Primitive</label>
        <link refid="class_geometry_1_1_primitive"/>
      </node>
      <node id="217">
        <label>Vector&lt; float &gt;</label>
        <link refid="class_geometry_1_1_vector"/>
        <childnode refid="218" relation="public-inheritance">
        </childnode>
      </node>
      <node id="215">
        <label>IIntersectable&lt; T &gt;</label>
        <link refid="class_geometry_1_1_i_intersectable"/>
      </node>
    </collaborationgraph>
    <location file="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" line="24" column="1" bodyfile="C:/Users/Jurecska/Desktop/Új mappa/Volume.h" bodystart="23" bodyend="93"/>
    <listofallmembers>
      <member refid="class_sampling_1_1_volume_1af98bbc751e90a15b59c81ee4c17630b2" prot="public" virt="non-virtual"><scope>Sampling::Volume</scope><name>getIso</name></member>
      <member refid="class_geometry_1_1_surface_1a3d7a6d87e670d2c6415e92a1f0e9feb4" prot="public" virt="non-virtual"><scope>Sampling::Volume</scope><name>getMaterial</name></member>
      <member refid="class_sampling_1_1_volume_1af9134066dc508e3201a1dea2acb755a8" prot="public" virt="virtual"><scope>Sampling::Volume</scope><name>getNormal</name></member>
      <member refid="class_sampling_1_1_volume_1aaf6cee9a80b3085218861a5a8d6b34bc" prot="public" virt="pure-virtual"><scope>Sampling::Volume</scope><name>getValueAt</name></member>
      <member refid="class_sampling_1_1_volume_1aae711dcbf18946964b9c42502e9d3377" prot="public" virt="virtual"><scope>Sampling::Volume</scope><name>intersect</name></member>
      <member refid="class_sampling_1_1_volume_1a8c8c997c19f49d10d5028ecd6d94805c" prot="protected" virt="non-virtual"><scope>Sampling::Volume</scope><name>iso</name></member>
      <member refid="class_geometry_1_1_surface_1aa2a46d8387923389a3aad30be0b8a8b5" prot="protected" virt="non-virtual"><scope>Sampling::Volume</scope><name>material</name></member>
      <member refid="class_sampling_1_1_volume_1a06df2552be7fe124a173741e8ba79770" prot="public" virt="non-virtual"><scope>Sampling::Volume</scope><name>setIso</name></member>
      <member refid="class_geometry_1_1_surface_1a26d09c46a06493cf2d9116991c80f816" prot="public" virt="non-virtual"><scope>Sampling::Volume</scope><name>setMaterial</name></member>
      <member refid="class_geometry_1_1_surface_1a6e1a6ad293d9318f65c2e28c468c66ba" prot="protected" virt="non-virtual"><scope>Sampling::Volume</scope><name>Surface</name></member>
      <member refid="class_geometry_1_1_surface_1a148c9d72f29cf29e7ad5e787e2819057" prot="protected" virt="non-virtual"><scope>Sampling::Volume</scope><name>Surface</name></member>
      <member refid="class_sampling_1_1_volume_1a3a8fada6f2d2b5ce58f6a0ffef34d9f1" prot="protected" virt="non-virtual"><scope>Sampling::Volume</scope><name>Volume</name></member>
      <member refid="class_sampling_1_1_volume_1aefc1e3fc5f3846e8a1f3186e06017b52" prot="protected" virt="non-virtual"><scope>Sampling::Volume</scope><name>Volume</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
