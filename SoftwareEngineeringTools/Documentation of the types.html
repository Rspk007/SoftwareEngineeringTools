<!DOCTYPE HTML>
<html>
	<head>
		<title>
			Documentation of the types
		</title><meta http-equiv="Content-type" content="text/html;charset=iso-8859-2">

	</head><link rel="stylesheet" type="text/css" href="css\RK.css"><body>
		<h1>
			Documentation of the types<br />
		</h1><a name="namespace_geometry"></a><h2>
			Namespace: Geometry<br />
		</h2><a name="class_geometry_1_1_a_a_b_b"></a><h3>
			Class: AABB<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> cornerFar<a name="class_geometry_1_1_a_a_b_b_1a73dd6c8490ac3e7704472f3d2e9714eb"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> cornerNear<a name="class_geometry_1_1_a_a_b_b_1aa208d421f143ee7d1c3987da538043e0"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> extents<a name="class_geometry_1_1_a_a_b_b_1ac9c90479b27ea8d59c674275220a389e"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> AABB(<a name="class_geometry_1_1_a_a_b_b_1abd87d1a03c4fa06e281c83b24a08b8cf"></a> const   corner  ,  const   extents  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Virtual  Constant <br /></td><td> containsPoint(<a name="class_geometry_1_1_a_a_b_b_1ab976492875a5b4b96d5953b135f163ba"></a> const   pointToCheck  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Virtual  Constant <br /></td><td> fitsPoint(<a name="class_geometry_1_1_a_a_b_b_1a0ed558489fd932d65c18e1fe6ea5d36f"></a> const   pointToCheck  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getCorner ()<a name="class_geometry_1_1_a_a_b_b_1a5ad7083826748770cbb479eeef716e62"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getExtents ()<a name="class_geometry_1_1_a_a_b_b_1afad9994c82c17faf59480d592f84faed"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Virtual  Constant <br /></td><td> intersect(<a name="class_geometry_1_1_a_a_b_b_1aae711dcbf18946964b9c42502e9d3377"></a> const   ray  ,  const   bounds  ,  const T &  scale  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> operator[](<a name="class_geometry_1_1_a_a_b_b_1a6335d7a8c9e1cda553d2d73621fcff77"></a> unsigned int  index  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> operator[](<a name="class_geometry_1_1_a_a_b_b_1aa4559350d6968f77e8c1d94965770f1e"></a> unsigned int  index  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setCorner(<a name="class_geometry_1_1_a_a_b_b_1aa0fa13dd17584cfb58b20ad1c0210a38"></a> const   corner  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  AABB(<a name="class_geometry_1_1_a_a_b_b_1abd87d1a03c4fa06e281c83b24a08b8cf"></a> const   corner  ,  const   extents  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /><b> corner: </b> - the point of the corner in the space, from which the extents will be measured <br /><b> extents: </b> - the extents of the AABB for each dimension <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  containsPoint(<a name="class_geometry_1_1_a_a_b_b_1ab976492875a5b4b96d5953b135f163ba"></a> const   pointToCheck  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This function can decide if a point is in the bounding volume, or not. (points of the surface are also true) <br /><b> point: </b> - the point to be checked <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - true if the point is in the Bounding Volume (and false otherwise) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  fitsPoint(<a name="class_geometry_1_1_a_a_b_b_1a0ed558489fd932d65c18e1fe6ea5d36f"></a> const   pointToCheck  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This function can decide if a point fits the <a href="#class_geometry_1_1_a_a_b_b"> AABB</a>  or not. <br /><b> point: </b> - the point to be checked <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - true if the point fits the <a href="#class_geometry_1_1_a_a_b_b"> AABB</a>  (and false otherwise) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getCorner ()<a name="class_geometry_1_1_a_a_b_b_1a5ad7083826748770cbb479eeef716e62"></a><br /></th>
			</tr><tr class="altColor">
				<td> This method can return the corner of the <a href="#class_geometry_1_1_a_a_b_b"> AABB</a> . <br /><b> Return:</b> - the corner of the <a href="#class_geometry_1_1_a_a_b_b"> AABB</a><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getExtents ()<a name="class_geometry_1_1_a_a_b_b_1afad9994c82c17faf59480d592f84faed"></a><br /></th>
			</tr><tr class="altColor">
				<td> This method can return the extents of the <a href="#class_geometry_1_1_a_a_b_b"> AABB</a>  for each dimension. <br /><b> Return:</b> - the extents of the <a href="#class_geometry_1_1_a_a_b_b"> AABB</a><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  intersect(<a name="class_geometry_1_1_a_a_b_b_1aae711dcbf18946964b9c42502e9d3377"></a> const   ray  ,  const   bounds  ,  const T &  scale  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function that implements the intersection with the concrete object. If no intersection was found, it will return an empty <a href="#class_geometry_1_1_vector"> Vector</a> . (0D <a href="#class_geometry_1_1_vector"> Vector</a> ) <br /><b> ray: </b> - the intersection ray <br /><b> bounds: </b> - the bounds between the intersection will be looked for <br /><b> scale: </b> - scale used by ray casting algorithms <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - The collection of intersections in ascending order of dimension time. <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  operator[](<a name="class_geometry_1_1_a_a_b_b_1a6335d7a8c9e1cda553d2d73621fcff77"></a> unsigned int  index  )<br /></th>
			</tr><tr class="altColor">
				<td> index operators They return the extent for the selected dimension. <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setCorner(<a name="class_geometry_1_1_a_a_b_b_1aa0fa13dd17584cfb58b20ad1c0210a38"></a> const   corner  )<br /></th>
			</tr><tr class="altColor">
				<td> This method can set the corner of the <a href="#class_geometry_1_1_a_a_b_b"> AABB</a> . <br /><b> corner: </b> - the new corner of the AABB<br /></td>
			</tr>
		</table> <br /><a name="class_geometry_1_1_bcc_grid"></a><h3>
			Class: BccGrid<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> baseCc<a name="class_geometry_1_1_bcc_grid_1a564dbc30d8aa35bfe9c8d4f3080e6bff"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> translatedCc<a name="class_geometry_1_1_bcc_grid_1a3b4f9de00f6c1bd43ea459473200f137"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> BccGrid(<a name="class_geometry_1_1_bcc_grid_1a454e098d6ce5f7da2d7489b6927a011d"></a> const   baseOrigin  ,  const T &  sideLength  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Virtual  Constant <br /></td><td> getFirstNeighbourCellVertices(<a name="class_geometry_1_1_bcc_grid_1a08afd8625c48e19c2f0e14d92eb50167"></a> const   point  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Virtual  Constant <br /></td><td> getLerpVertices(<a name="class_geometry_1_1_bcc_grid_1ab4c0f69ae16cd070e5612327aac89159"></a> const   point  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Virtual  Constant <br /></td><td> getNearestPoint(<a name="class_geometry_1_1_bcc_grid_1a4bbb251dd45b8dab47447f175b8e791c"></a> const   point  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getOrigin ()<a name="class_geometry_1_1_bcc_grid_1a835c7cb37506f78b00265bdee05795e6"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getSideLength ()<a name="class_geometry_1_1_bcc_grid_1ac4cc89dbd0cf8ea48d204b3dda86db72"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setOrigin(<a name="class_geometry_1_1_bcc_grid_1ad4f551157f1aef8e0020c1708e607aed"></a> const   baseOrigin  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> setSideLength(<a name="class_geometry_1_1_bcc_grid_1a31f75e1d9923ef16f08abfc1fcfa939f"></a> const T &  sideLength  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  BccGrid(<a name="class_geometry_1_1_bcc_grid_1a454e098d6ce5f7da2d7489b6927a011d"></a> const   baseOrigin  ,  const T &  sideLength  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /><b> baseOrigin: </b> - the origin point in world coordinates of the base CC <br /><b> sideLength: </b> - the side length of the unit cell (should be a positive number) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  getFirstNeighbourCellVertices(<a name="class_geometry_1_1_bcc_grid_1a08afd8625c48e19c2f0e14d92eb50167"></a> const   point  )<br /></th>
			</tr><tr class="altColor">
				<td> This method gets a point, and returns in a vector all of the first neighbour points of this. The method doesn't check, if the point in the argument fits a lattice point, or not! <br /><b> point: </b> - the point whose first neighbours we are looking for <br /><b> Return:</b> - a vector of the first neighbours (each is given in world coordinates!) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  getLerpVertices(<a name="class_geometry_1_1_bcc_grid_1ab4c0f69ae16cd070e5612327aac89159"></a> const   point  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This method gets a point, and returns in a vector all of the vertices whose value influences the linear interpolation of the selected point. <br /><b> point: </b> - the point whose lerp-vertices we are looking for <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  getNearestPoint(<a name="class_geometry_1_1_bcc_grid_1a4bbb251dd45b8dab47447f175b8e791c"></a> const   point  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This method can return the lattice point in whose Voronoi-region is the given point. This lattice point is the nearest neighbour point of the given point. <br /><b> point: </b> - the point whose nearest neighbour we are looking for <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - the nearest neighbour point in the lattice in world coordinates (not in lattice locale coordinates!) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getOrigin ()<a name="class_geometry_1_1_bcc_grid_1a835c7cb37506f78b00265bdee05795e6"></a><br /></th>
			</tr><tr class="altColor">
				<td> This method returns the actual value of the origin of the grid. <br /><b> Return:</b> - the actual origin of the grid <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getSideLength ()<a name="class_geometry_1_1_bcc_grid_1ac4cc89dbd0cf8ea48d204b3dda86db72"></a><br /></th>
			</tr><tr class="altColor">
				<td> This method returns the actual value of the side length of the unit cell. <br /><b> Return:</b> - the actual side length of the unit cell <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setOrigin(<a name="class_geometry_1_1_bcc_grid_1ad4f551157f1aef8e0020c1708e607aed"></a> const   baseOrigin  )<br /></th>
			</tr><tr class="altColor">
				<td> This method can set origin of the grid. <br /><b> origin: </b> - the new origin <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setSideLength(<a name="class_geometry_1_1_bcc_grid_1a31f75e1d9923ef16f08abfc1fcfa939f"></a> const T &  sideLength  )<br /></th>
			</tr><tr class="altColor">
				<td> This method can set the side length (resolution) of the grid. <br /><b> sideLength: </b> - the side length of the unit cell (should be a positive number) <br /></td>
			</tr>
		</table> <br /><a name="class_geometry_1_1_bounding_volume"></a><h3>
			Class: BoundingVolume<br />
		</h3><h4>
			Fields<br />
		</h4><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Abstract  Constant <br /></td><td> containsPoint(<a name="class_geometry_1_1_bounding_volume_1a68b13a7b73dc378f894c8e05b4e0dfd4"></a> const   pointToCheck  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Abstract  Constant <br /></td><td> fitsPoint(<a name="class_geometry_1_1_bounding_volume_1af76e4d614fde54d8572ff3686b157456"></a> const   pointToCheck  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Abstract  Constant <br /></td><td> intersect(<a name="class_geometry_1_1_bounding_volume_1ab7b27cca569f9eae8628dd93e54c2d3e"></a> const   ray  ,  const   bounds  ,  const T &  scale  ,  const   Toperators  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  containsPoint(<a name="class_geometry_1_1_bounding_volume_1a68b13a7b73dc378f894c8e05b4e0dfd4"></a> const   pointToCheck  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This function can decide if a point is in the bounding volume, or not. (points of the surface are also true) <br /><b> point: </b> - the point to be checked <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - true if the point is in the Bounding Volume (and false otherwise) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  fitsPoint(<a name="class_geometry_1_1_bounding_volume_1af76e4d614fde54d8572ff3686b157456"></a> const   pointToCheck  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This function can decide if a point fits the surface of the Bounding Volume or not. <br /><b> point: </b> - the point to be checked <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - true if the point fits the surface of the Bounding Volume (and false otherwise) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  intersect(<a name="class_geometry_1_1_bounding_volume_1ab7b27cca569f9eae8628dd93e54c2d3e"></a> const   ray  ,  const   bounds  ,  const T &  scale  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function that implements the intersection with the concrete object. If no intersection was found, it will return an empty <a href="#class_geometry_1_1_vector"> Vector</a> . (0D <a href="#class_geometry_1_1_vector"> Vector</a> ) <br /><b> ray: </b> - the intersection ray <br /><b> bounds: </b> - the bounds between the intersection will be looked for <br /><b> scale: </b> - scale used by ray casting algorithms <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - The collection of intersections in ascending order of dimension time. <br /></td>
			</tr>
		</table> <br /><a name="class_geometry_1_1_cc_grid"></a><h3>
			Class: CcGrid<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> origin<a name="class_geometry_1_1_cc_grid_1a5d8fe3fccb91132ff5328f69105bcda2"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> sideLength<a name="class_geometry_1_1_cc_grid_1a75b94af80f9cec348d50461cd6823cb7"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> sideLengthHalf<a name="class_geometry_1_1_cc_grid_1a498ab2db3cb1dc1a9fba46068a8b212f"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> CcGrid(<a name="class_geometry_1_1_cc_grid_1a96888b7acc6998682dd39eecd2e1a1e7"></a> const   origin  ,  const T &  sideLength  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Virtual  Constant <br /></td><td> getFirstNeighbourCellVertices(<a name="class_geometry_1_1_cc_grid_1a08afd8625c48e19c2f0e14d92eb50167"></a> const   point  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Virtual  Constant <br /></td><td> getLerpVertices(<a name="class_geometry_1_1_cc_grid_1ab4c0f69ae16cd070e5612327aac89159"></a> const   point  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Virtual  Constant <br /></td><td> getNearestPoint(<a name="class_geometry_1_1_cc_grid_1a4bbb251dd45b8dab47447f175b8e791c"></a> const   point  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getOrigin ()<a name="class_geometry_1_1_cc_grid_1a835c7cb37506f78b00265bdee05795e6"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getSideLength ()<a name="class_geometry_1_1_cc_grid_1ac4cc89dbd0cf8ea48d204b3dda86db72"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setOrigin(<a name="class_geometry_1_1_cc_grid_1a34ad13cdd79d72ee51591dab2b0fc8d2"></a> const   origin  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> setSideLength(<a name="class_geometry_1_1_cc_grid_1a31f75e1d9923ef16f08abfc1fcfa939f"></a> const T &  sideLength  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  CcGrid(<a name="class_geometry_1_1_cc_grid_1a96888b7acc6998682dd39eecd2e1a1e7"></a> const   origin  ,  const T &  sideLength  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /><b> origin: </b> - the origin point in world coordinates <br /><b> sideLength: </b> - the side length of the unit cell (should be a positive number) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  getFirstNeighbourCellVertices(<a name="class_geometry_1_1_cc_grid_1a08afd8625c48e19c2f0e14d92eb50167"></a> const   point  )<br /></th>
			</tr><tr class="altColor">
				<td> This method gets a point, and returns in a vector all of the first neighbour points of this. The method doesn't check, if the point in the argument fits a lattice point, or not! <br /><b> point: </b> - the point whose first neighbours we are looking for <br /><b> Return:</b> - a vector of the first neighbours (each is given in world coordinates!) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  getLerpVertices(<a name="class_geometry_1_1_cc_grid_1ab4c0f69ae16cd070e5612327aac89159"></a> const   point  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This method gets a point, and returns in a vector all of the vertices whose value influences the linear interpolation of the selected point. <br /><b> point: </b> - the point whose lerp-vertices we are looking for <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  getNearestPoint(<a name="class_geometry_1_1_cc_grid_1a4bbb251dd45b8dab47447f175b8e791c"></a> const   point  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This method can return the lattice point in whose Voronoi-region is the given point. This lattice point is the nearest neighbour point of the given point. <br /><b> point: </b> - the point whose nearest neighbour we are looking for <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - the nearest neighbour point in the lattice in world coordinates (not in lattice locale coordinates!) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getOrigin ()<a name="class_geometry_1_1_cc_grid_1a835c7cb37506f78b00265bdee05795e6"></a><br /></th>
			</tr><tr class="altColor">
				<td> This method returns the actual value of the origin of the grid. <br /><b> Return:</b> - the actual origin of the grid <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getSideLength ()<a name="class_geometry_1_1_cc_grid_1ac4cc89dbd0cf8ea48d204b3dda86db72"></a><br /></th>
			</tr><tr class="altColor">
				<td> This method returns the actual value of the side length of the unit cell. <br /><b> Return:</b> - the actual side length of the unit cell <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setOrigin(<a name="class_geometry_1_1_cc_grid_1a34ad13cdd79d72ee51591dab2b0fc8d2"></a> const   origin  )<br /></th>
			</tr><tr class="altColor">
				<td> This method can set origin of the grid. <br /><b> origin: </b> - the new origin <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setSideLength(<a name="class_geometry_1_1_cc_grid_1a31f75e1d9923ef16f08abfc1fcfa939f"></a> const T &  sideLength  )<br /></th>
			</tr><tr class="altColor">
				<td> This method can set the side length (resolution) of the grid. <br /><b> sideLength: </b> - the side length of the unit cell (should be a positive number) <br /></td>
			</tr>
		</table> <br /><a name="class_geometry_1_1_grid"></a><h3>
			Class: Grid<br />
		</h3><h4>
			Fields<br />
		</h4><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Abstract  Constant <br /></td><td> getFirstNeighbourCellVertices(<a name="class_geometry_1_1_grid_1a7947b840d23ada9abd70df77ce4a9c06"></a> const   point  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Abstract  Constant <br /></td><td> getLerpVertices(<a name="class_geometry_1_1_grid_1a43bd5e3ba4d39448cd92477df03b84a2"></a> const   point  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Abstract  Constant <br /></td><td> getNearestPoint(<a name="class_geometry_1_1_grid_1a2cdc42bd1e012a3b8473d518b7c2f6b0"></a> const   point  ,  const   Toperators  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  getFirstNeighbourCellVertices(<a name="class_geometry_1_1_grid_1a7947b840d23ada9abd70df77ce4a9c06"></a> const   point  )<br /></th>
			</tr><tr class="altColor">
				<td> This method gets a point, and returns in a vector all of the first neighbour points of this. The method doesn't check, if the point in the argument fits a lattice point, or not! <br /><b> point: </b> - the point whose first neighbours we are looking for <br /><b> Return:</b> - a vector of the first neighbours (each is given in world coordinates!) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  getLerpVertices(<a name="class_geometry_1_1_grid_1a43bd5e3ba4d39448cd92477df03b84a2"></a> const   point  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This method gets a point, and returns in a vector all of the vertices whose value influences the linear interpolation of the selected point. <br /><b> point: </b> - the point whose lerp-vertices we are looking for <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  getNearestPoint(<a name="class_geometry_1_1_grid_1a2cdc42bd1e012a3b8473d518b7c2f6b0"></a> const   point  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This method can return the lattice point in whose Voronoi-region is the given point. This lattice point is the nearest neighbour point of the given point. <br /><b> point: </b> - the point whose nearest neighbour we are looking for <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - the nearest neighbour point in the lattice in world coordinates (not in lattice locale coordinates!) <br /></td>
			</tr>
		</table> <br /><a name="class_geometry_1_1_i_intersectable"></a><h3>
			Class: IIntersectable<br />
		</h3><h4>
			Fields<br />
		</h4><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Abstract  Constant <br /></td><td> intersect(<a name="class_geometry_1_1_i_intersectable_1ab7b27cca569f9eae8628dd93e54c2d3e"></a> const   ray  ,  const   bounds  ,  const T &  scale  ,  const   Toperators  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  intersect(<a name="class_geometry_1_1_i_intersectable_1ab7b27cca569f9eae8628dd93e54c2d3e"></a> const   ray  ,  const   bounds  ,  const T &  scale  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function that implements the intersection with the concrete object. If no intersection was found, it will return an empty <a href="#class_geometry_1_1_vector"> Vector</a> . (0D <a href="#class_geometry_1_1_vector"> Vector</a> ) <br /><b> ray: </b> - the intersection ray <br /><b> bounds: </b> - the bounds between the intersection will be looked for <br /><b> scale: </b> - scale used by ray casting algorithms <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - The collection of intersections in ascending order of dimension time. <br /></td>
			</tr>
		</table> <br /><a name="struct_geometry_1_1_intersection"></a><h3>
			Struct: Intersection<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> material<a name="struct_geometry_1_1_intersection_1aa2a46d8387923389a3aad30be0b8a8b5"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> obj<a name="struct_geometry_1_1_intersection_1ab8d449d29d16e7cbf5997c030c8a401a"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> position<a name="struct_geometry_1_1_intersection_1a92c08fdee4c3d7ce4f5180f6222a9a13"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> ray<a name="struct_geometry_1_1_intersection_1ab6e431ff5ef4b9a0ccecd75250c8fa9e"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> time<a name="struct_geometry_1_1_intersection_1a6f88871e9000141586c249d6bb326e51"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> value<a name="struct_geometry_1_1_intersection_1a4fc7f59e3113e19697159919a5aad095"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> Intersection ()<a name="struct_geometry_1_1_intersection_1ae8bc77e85ab6570502b0596aac795e84"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> Intersection(<a name="struct_geometry_1_1_intersection_1ad248b158cd16092526935f1a93c3ce7c"></a> const   obj  ,  const   position  ,  const T &  time  ,  const   ray  ,  const T &  value  ,  const   material  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Intersection ()<a name="struct_geometry_1_1_intersection_1ae8bc77e85ab6570502b0596aac795e84"></a><br /></th>
			</tr><tr class="altColor">
				<td> default c'tor <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Intersection(<a name="struct_geometry_1_1_intersection_1ad248b158cd16092526935f1a93c3ce7c"></a> const   obj  ,  const   position  ,  const T &  time  ,  const   ray  ,  const T &  value  ,  const   material  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /></td>
			</tr>
		</table> <br /><a name="class_geometry_1_1_i_shape"></a><h3>
			Class: IShape<br />
		</h3><h4>
			Fields<br />
		</h4><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Abstract  Constant <br /></td><td> fitsPoint(<a name="class_geometry_1_1_i_shape_1af76e4d614fde54d8572ff3686b157456"></a> const   pointToCheck  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Abstract  Constant <br /></td><td> intersect(<a name="class_geometry_1_1_i_shape_1ab7b27cca569f9eae8628dd93e54c2d3e"></a> const   ray  ,  const   bounds  ,  const T &  scale  ,  const   Toperators  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  fitsPoint(<a name="class_geometry_1_1_i_shape_1af76e4d614fde54d8572ff3686b157456"></a> const   pointToCheck  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This function can decide if a point fits the Shape or not. <br /><b> point: </b> - the point to be checked <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - true if the point fits the Shape (and false otherwise) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  intersect(<a name="class_geometry_1_1_i_shape_1ab7b27cca569f9eae8628dd93e54c2d3e"></a> const   ray  ,  const   bounds  ,  const T &  scale  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function that implements the intersection with the concrete object. If no intersection was found, it will return an empty <a href="#class_geometry_1_1_vector"> Vector</a> . (0D <a href="#class_geometry_1_1_vector"> Vector</a> ) <br /><b> ray: </b> - the intersection ray <br /><b> bounds: </b> - the bounds between the intersection will be looked for <br /><b> scale: </b> - scale used by ray casting algorithms <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - The collection of intersections in ascending order of dimension time. <br /></td>
			</tr>
		</table> <br /><a name="class_geometry_1_1_line"></a><h3>
			Class: Line<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> dirVector<a name="class_geometry_1_1_line_1ae1e7c02846f1a96c3a21310215d91dd6"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> point<a name="class_geometry_1_1_line_1ad4e45818b9c5c15da68a84bb59576bd2"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Virtual  Constant <br /></td><td> fitsPoint(<a name="class_geometry_1_1_line_1a0ed558489fd932d65c18e1fe6ea5d36f"></a> const   pointToCheck  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getDirection ()<a name="class_geometry_1_1_line_1ad79403432a09aebc40318f64daf9df2b"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getNormal ()<a name="class_geometry_1_1_line_1a46cadd1148ff6a6ee448d556c8b2a909"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> Line(<a name="class_geometry_1_1_line_1abe75f6ce7448a3f3aba4dd98ff4f9d0d"></a> const   dirVector  ,  const   point  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  fitsPoint(<a name="class_geometry_1_1_line_1a0ed558489fd932d65c18e1fe6ea5d36f"></a> const   pointToCheck  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This function can decide if a point fits the line or not. <br /><b> Return:</b> - true if the point fits the line (and false otherwise) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getDirection ()<a name="class_geometry_1_1_line_1ad79403432a09aebc40318f64daf9df2b"></a><br /></th>
			</tr><tr class="altColor">
				<td> This function can return the direction vector of the line. <br /><b> Return:</b> - the direction vector (not necessarily unit vector!) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getNormal ()<a name="class_geometry_1_1_line_1a46cadd1148ff6a6ee448d556c8b2a909"></a><br /></th>
			</tr><tr class="altColor">
				<td> This function can return a normal vector of the line. <br /><b> Return:</b> - a normal vector (not necessarily unit vector!) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Line(<a name="class_geometry_1_1_line_1abe75f6ce7448a3f3aba4dd98ff4f9d0d"></a> const   dirVector  ,  const   point  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /><b> dirVector: </b> - a direction vector of the line <br /><b> point: </b> - a point fitting the line <br /></td>
			</tr>
		</table> <br /><a name="class_geometry_1_1_matrix"></a><h3>
			Class: Matrix<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Private <br /></td><td> m<a name="class_geometry_1_1_matrix_1a4033037df26775dd60840e66d38a08ba"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Private <br /></td><td> n<a name="class_geometry_1_1_matrix_1a7d46b74409bd32b539089ef4721ea544"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Private <br /></td><td> rowVects<a name="class_geometry_1_1_matrix_1ab6006ee116558e64a0450ed85571e324"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Virtual <br /></td><td> ~Matrix ()<a name="class_geometry_1_1_matrix_1a2249c859d9c3503ec00d3a20fe963842"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getAdj ()<a name="class_geometry_1_1_matrix_1af4d2ab764acdc315eeee518996890688"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getCol(<a name="class_geometry_1_1_matrix_1afedf179b5676991a95e6278174614a26"></a> unsigned int  ind  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getDet ()<a name="class_geometry_1_1_matrix_1ab577821468783592ec1e17b9831a745f"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getGauss ()<a name="class_geometry_1_1_matrix_1a23c6d59f23f1ac9227af3eed332bc503"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getHeight ()<a name="class_geometry_1_1_matrix_1ada86e8057bfee1ecc58f9c697f31e666"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getInv ()<a name="class_geometry_1_1_matrix_1a0b7e52ecf23c67a0c9b28b0488428467"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getMinor(<a name="class_geometry_1_1_matrix_1a60f4bc5ba2e3e3641cd8adfe3220ce47"></a> unsigned int  ni  ,  unsigned int  mi  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getRow(<a name="class_geometry_1_1_matrix_1a1f1906594042db4f2f5476d0fbd62dc0"></a> unsigned int  ind  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getTransp ()<a name="class_geometry_1_1_matrix_1a023fe3a9126ea5712956732212e2c3b3"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getWidth ()<a name="class_geometry_1_1_matrix_1ae7f5205133978fea4b9de9165fef5d34"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> isQuad ()<a name="class_geometry_1_1_matrix_1a89a6bb46fa0494bfc4517958a6b7f97e"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> Matrix(<a name="class_geometry_1_1_matrix_1acba920a0f45f1897f7d829686e6fc866"></a> unsigned int  n  ,  unsigned int  m  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> Matrix(<a name="class_geometry_1_1_matrix_1a7acef296df8ffb0fdac4a98ee1ceebb8"></a> unsigned int  n  ,  unsigned int  m  ,  T *  elements  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> Matrix(<a name="class_geometry_1_1_matrix_1a7f4c5e25b1b023ae9aa954e19df2578b"></a> const   rows  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> Matrix(<a name="class_geometry_1_1_matrix_1a5e72b7c50059bf70eca50ada11a4cf88"></a> const   other  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> operator- ()<a name="class_geometry_1_1_matrix_1abe1cc06180dac9a63b50c976cfd64177"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> operator-(<a name="class_geometry_1_1_matrix_1aafe24c6032210e26b7d5c5de4b465c4a"></a> const   other  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> operator!=(<a name="class_geometry_1_1_matrix_1a794f46a3822d62168c9892b12f605c9b"></a> const   other  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> operator()(<a name="class_geometry_1_1_matrix_1a59468b5083322ec7ba701c1008d6a36c"></a> unsigned int  ind1  ,  unsigned int  ind2  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> operator()(<a name="class_geometry_1_1_matrix_1a3948cc41be8fbb1c45fc1c5e89b5ad0b"></a> unsigned int  ind1  ,  unsigned int  ind2  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> operator*(<a name="class_geometry_1_1_matrix_1ac89891039ea560e097eb08132f26aa16"></a> const   other  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> operator*(<a name="class_geometry_1_1_matrix_1a604b5f84ed6de96ab488d2c03eae7547"></a> const T &  scalar  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> operator*(<a name="class_geometry_1_1_matrix_1a2b2be23d8d328c53abdc80f175aebc94"></a> const   vect  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> operator*(<a name="class_geometry_1_1_matrix_1a63b3686883388b1c88a567e5ec8076f3"></a> const   other  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> operator*=(<a name="class_geometry_1_1_matrix_1ad94bc05c753a821e904fac0a1b164b18"></a> const T &  scalar  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> operator[](<a name="class_geometry_1_1_matrix_1a3379ea51ab8e20aa8cc9b0e9fed95333"></a> unsigned int  ind  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> operator+(<a name="class_geometry_1_1_matrix_1a780f345c8ffec32c9998dd4ee7bb3f83"></a> const   other  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> operator+=(<a name="class_geometry_1_1_matrix_1aa518bac1257096533b04d8bbc0ef720d"></a> const   other  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> operator=(<a name="class_geometry_1_1_matrix_1a979fa9f2ef9ed49fe50843536b80ef64"></a> const   other  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> operator-=(<a name="class_geometry_1_1_matrix_1a269caf81214ddca3d350f4f9abc92e53"></a> const   other  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> operator==(<a name="class_geometry_1_1_matrix_1a0505b89eda121fdff45c7a857e485557"></a> const   other  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setCol(<a name="class_geometry_1_1_matrix_1a3386131a5370853ac9c36b433ceb8922"></a> unsigned int  ind  ,  const   newVect  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Virtual <br /></td><td> setHeight(<a name="class_geometry_1_1_matrix_1a4c45c93b09aefe28888e515b59dac801"></a> unsigned int  newHeight  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setRow(<a name="class_geometry_1_1_matrix_1a84c53d147111d22a4169cefcd9df1f2d"></a> unsigned int  ind  ,  const   newVect  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Virtual <br /></td><td> setWidth(<a name="class_geometry_1_1_matrix_1ad17b14cee5af2ebc8012f5d6ba84ae40"></a> unsigned int  newWidth  )<br /><br /></td>
			</tr>
		</table> <br /><a name="class_geometry_1_1_plane"></a><h3>
			Class: Plane<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> normalVector<a name="class_geometry_1_1_plane_1aa7b243864338e643656feeb2fa4ccfbb"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> point<a name="class_geometry_1_1_plane_1ad4e45818b9c5c15da68a84bb59576bd2"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Virtual  Constant <br /></td><td> fitsPoint(<a name="class_geometry_1_1_plane_1a0ed558489fd932d65c18e1fe6ea5d36f"></a> const   pointToCheck  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getNormal ()<a name="class_geometry_1_1_plane_1a46cadd1148ff6a6ee448d556c8b2a909"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Virtual  Constant <br /></td><td> intersect(<a name="class_geometry_1_1_plane_1aae711dcbf18946964b9c42502e9d3377"></a> const   ray  ,  const   bounds  ,  const T &  scale  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> Plane(<a name="class_geometry_1_1_plane_1a242f153285fa75214215c0bd7cf82680"></a> const   normalVector  ,  const   point  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  fitsPoint(<a name="class_geometry_1_1_plane_1a0ed558489fd932d65c18e1fe6ea5d36f"></a> const   pointToCheck  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This function can decide if a point fits the plane or not. <br /><b> point: </b> - the point to be checked <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - true if the point fits the plane (and false otherwise) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getNormal ()<a name="class_geometry_1_1_plane_1a46cadd1148ff6a6ee448d556c8b2a909"></a><br /></th>
			</tr><tr class="altColor">
				<td> This function can return a normal vector of the plane. <br /><b> Return:</b> - a normal vector (not necessarily unit vector!) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  intersect(<a name="class_geometry_1_1_plane_1aae711dcbf18946964b9c42502e9d3377"></a> const   ray  ,  const   bounds  ,  const T &  scale  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function that implements the intersection with the concrete object. If no intersection was found, it will return an empty <a href="#class_geometry_1_1_vector"> Vector</a> . (0D <a href="#class_geometry_1_1_vector"> Vector</a> ) <br /><b> ray: </b> - the intersection ray <br /><b> bounds: </b> - the bounds between the intersection will be looked for <br /><b> scale: </b> - scale used by ray casting algorithms <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - The collection of intersections in ascending order of dimension time. <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Plane(<a name="class_geometry_1_1_plane_1a242f153285fa75214215c0bd7cf82680"></a> const   normalVector  ,  const   point  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /><b> normalVector: </b> - a normal vector of the plane <br /><b> point: </b> - a point fitting the plane <br /></td>
			</tr>
		</table> <br /><a name="class_geometry_1_1_point"></a><h3>
			Class: Point<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> coords<a name="class_geometry_1_1_point_1a529efcc7ac851fc35b2ac169251d9204"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> dim<a name="class_geometry_1_1_point_1ad335dc2821e58000fb6d0f0ed6ba835f"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Virtual <br /></td><td> ~Point ()<a name="class_geometry_1_1_point_1a7e2e45db495d5d441e5dcb1075925e60"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getDim ()<a name="class_geometry_1_1_point_1a0ec9df17ac56bb737d58485bf35eaf74"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getDistance(<a name="class_geometry_1_1_point_1a3511f63e157f5461231c38eaa7db801a"></a> const   other  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> operator!=(<a name="class_geometry_1_1_point_1a02de908c720261092f9384fe46cdc505"></a> const   other  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> operator[](<a name="class_geometry_1_1_point_1a6335d7a8c9e1cda553d2d73621fcff77"></a> unsigned int  index  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> operator[](<a name="class_geometry_1_1_point_1aa4559350d6968f77e8c1d94965770f1e"></a> unsigned int  index  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> operator=(<a name="class_geometry_1_1_point_1a91533c7b122673f53e41b20c3f4ec7e3"></a> const   other  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> operator==(<a name="class_geometry_1_1_point_1a1f3fdd51f39513a79c907ee69e0fa885"></a> const   other  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> Point(<a name="class_geometry_1_1_point_1a2f4d8ea275f33e07b31136fdd34c5c0f"></a> unsigned int  dim  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> Point(<a name="class_geometry_1_1_point_1a6c40b949236b5a3a9acd921d253b8249"></a> unsigned int  dim  ,  const T &  fillValue  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> Point(<a name="class_geometry_1_1_point_1a61bdd31845ff0ff50ae026c37b8a4486"></a> unsigned int  dim  ,  const T *  coord_array  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> Point(<a name="class_geometry_1_1_point_1a383ee92cd12d8fcafc7df62084caf7b2"></a> const   other  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setDim(<a name="class_geometry_1_1_point_1ae4e043e657d0526c008a264b583ecfcd"></a> unsigned int  newDim  ,  T  data  )<br /><br /></td>
			</tr>
		</table> <br /><a name="class_geometry_1_1_primitive"></a><h3>
			Class: Primitive<br />
		</h3><h4>
			Fields<br />
		</h4><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> Primitive ()<a name="class_geometry_1_1_primitive_1a372847a827bf3fcf09859d22aa98c546"></a><br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Protected  Primitive ()<a name="class_geometry_1_1_primitive_1a372847a827bf3fcf09859d22aa98c546"></a><br /></th>
			</tr><tr class="altColor">
				<td><a href="#class_geometry_1_1_primitive"> Primitive</a>  is an abstract class for geometry primitives. It shouldn't be instantied! <br /></td>
			</tr>
		</table> <br /><a name="class_geometry_1_1_ray"></a><h3>
			Class: Ray<br />
		</h3><h4>
			Fields<br />
		</h4><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Virtual  Constant <br /></td><td> fitsPoint(<a name="class_geometry_1_1_ray_1a0ed558489fd932d65c18e1fe6ea5d36f"></a> const   pointToCheck  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getOrigin ()<a name="class_geometry_1_1_ray_1a835c7cb37506f78b00265bdee05795e6"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> Ray(<a name="class_geometry_1_1_ray_1a13399949a12a25f2ee3badb55d326957"></a> const   dirVector  ,  const   origin  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  fitsPoint(<a name="class_geometry_1_1_ray_1a0ed558489fd932d65c18e1fe6ea5d36f"></a> const   pointToCheck  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This function can decide if a point is in the route of the ray, or not. (points in negative direction are not fitting!) <br /><b> Return:</b> - true if the point fits the ray (and false otherwise) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getOrigin ()<a name="class_geometry_1_1_ray_1a835c7cb37506f78b00265bdee05795e6"></a><br /></th>
			</tr><tr class="altColor">
				<td> This function can return the origin of the ray. <br /><b> Return:</b> - the origin of the ray <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Ray(<a name="class_geometry_1_1_ray_1a13399949a12a25f2ee3badb55d326957"></a> const   dirVector  ,  const   origin  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /><b> dirVector: </b> - a direction vector of the ray <br /><b> origin: </b> - the origin point of the ray <br /></td>
			</tr>
		</table> <br /><a name="class_geometry_1_1_surface"></a><h3>
			Class: Surface<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> material<a name="class_geometry_1_1_surface_1aa2a46d8387923389a3aad30be0b8a8b5"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getMaterial ()<a name="class_geometry_1_1_surface_1a3d7a6d87e670d2c6415e92a1f0e9feb4"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Abstract  Constant <br /></td><td> getNormal(<a name="class_geometry_1_1_surface_1a9f3f940415136a6c508a0d9de1683adb"></a> Vector  point  ,  const T &  scale  ,  T  value  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Abstract  Constant <br /></td><td> intersect(<a name="class_geometry_1_1_surface_1ab7b27cca569f9eae8628dd93e54c2d3e"></a> const   ray  ,  const   bounds  ,  const T &  scale  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> setMaterial(<a name="class_geometry_1_1_surface_1a26d09c46a06493cf2d9116991c80f816"></a> const   material  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> Surface ()<a name="class_geometry_1_1_surface_1a6e1a6ad293d9318f65c2e28c468c66ba"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> Surface(<a name="class_geometry_1_1_surface_1a148c9d72f29cf29e7ad5e787e2819057"></a> const   material  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getMaterial ()<a name="class_geometry_1_1_surface_1a3d7a6d87e670d2c6415e92a1f0e9feb4"></a><br /></th>
			</tr><tr class="altColor">
				<td> Getter function for the material of the surface. <br /><b> Return:</b> - the material of the surface <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  getNormal(<a name="class_geometry_1_1_surface_1a9f3f940415136a6c508a0d9de1683adb"></a> Vector  point  ,  const T &  scale  ,  T  value  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function that can approximate a normal vector to the surface at a given point. <br /><b> point: </b> - the point whose normal vector we are interested <br /><b> scale: </b> - the scale parameter defines the distance from point in each dimension to build the gradient vector <br /><b> value: </b> - the value at the point won't be recomputed, if it's given in this parameter <br /><b> Toperators: </b> - the operators object of type T <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  intersect(<a name="class_geometry_1_1_surface_1ab7b27cca569f9eae8628dd93e54c2d3e"></a> const   ray  ,  const   bounds  ,  const T &  scale  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function that implements the intersection with the concrete object. If no intersection was found, it will return an empty <a href="#class_geometry_1_1_vector"> Vector</a> . (0D <a href="#class_geometry_1_1_vector"> Vector</a> ) <br /><b> ray: </b> - the intersection ray <br /><b> bounds: </b> - the bounds between the intersection will be looked for <br /><b> scale: </b> - scale used by ray casting algorithms <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - The collection of intersections in ascending order of dimension time. <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setMaterial(<a name="class_geometry_1_1_surface_1a26d09c46a06493cf2d9116991c80f816"></a> const   material  )<br /></th>
			</tr><tr class="altColor">
				<td> Setter function for the material of the surface. <br /><b> material: </b> - the new material of the surface <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Protected  Surface ()<a name="class_geometry_1_1_surface_1a6e1a6ad293d9318f65c2e28c468c66ba"></a><br /></th>
			</tr><tr class="altColor">
				<td> default c'tor <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Protected  Surface(<a name="class_geometry_1_1_surface_1a148c9d72f29cf29e7ad5e787e2819057"></a> const   material  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /></td>
			</tr>
		</table> <br /><a name="class_geometry_1_1_vector"></a><h3>
			Class: Vector<br />
		</h3><h4>
			Fields<br />
		</h4><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Virtual <br /></td><td> ~Vector ()<a name="class_geometry_1_1_vector_1aaa9fccd0cb7734271f7a15e5d9dc0d27"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getAbs ()<a name="class_geometry_1_1_vector_1a071a16e2751b87f96d737ed29935504f"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getNormal ()<a name="class_geometry_1_1_vector_1a46cadd1148ff6a6ee448d556c8b2a909"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getUnit ()<a name="class_geometry_1_1_vector_1af79f2ffce20c5ea4419911b8e05ec010"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> multiply(<a name="class_geometry_1_1_vector_1a7159dc27804d89cb3b9a8269c6f886e7"></a> const   other  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> operator- ()<a name="class_geometry_1_1_vector_1a5a1c5bc7156428e3a99ebf29b1cb6a81"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> operator-(<a name="class_geometry_1_1_vector_1adb3ea8daecc1a317f267016201fd48a8"></a> const   other  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> operator*(<a name="class_geometry_1_1_vector_1a6fc6bcceeab50b1cde1f61aa42c6a658"></a> const T &  scalar  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> operator*(<a name="class_geometry_1_1_vector_1a6a0e13b8f2c0a47ca1a464247ec22b76"></a> const   other  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> operator*=(<a name="class_geometry_1_1_vector_1af05c0999abc2400be5e94a2104ffb8ab"></a> const T &  scalar  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> operator+(<a name="class_geometry_1_1_vector_1aefdc7a9f17403901c29166ff904a6622"></a> const   other  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> operator+=(<a name="class_geometry_1_1_vector_1a89fa44215e15be0aac36dcd4b0f7b271"></a> const   other  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> operator-=(<a name="class_geometry_1_1_vector_1ac22e1b7043ab74b8644187047b716ac9"></a> const   other  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> Vector(<a name="class_geometry_1_1_vector_1a161dd947cc220fb28a09f9db73b67483"></a> unsigned int  dim  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> Vector(<a name="class_geometry_1_1_vector_1a96419b5b9a2c3b07725b94690aef72ee"></a> unsigned int  dim  ,  const T &  fillValue  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> Vector(<a name="class_geometry_1_1_vector_1acf3021033f9ef47e1463826cac57d979"></a> unsigned int  dim  ,  const T *  coord_array  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> Vector(<a name="class_geometry_1_1_vector_1ae18a5c54fc21fb5fe69fbfb8e18275f7"></a> const   other  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> Vector(<a name="class_geometry_1_1_vector_1abd9a214aef1c99357ceaeffb60352ba2"></a> const   other  )<br /><br /></td>
			</tr>
		</table> <br /><a name="namespace_sampling"></a><h2>
			Namespace: Sampling<br />
		</h2><a name="class_sampling_1_1_filter"></a><h3>
			Class: Filter<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> active<a name="class_sampling_1_1_filter_1a03c996f9fcf0e10baeb3e700be0c409a"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> filteredObject<a name="class_sampling_1_1_filter_1a20abde6a69cb7dfbe98468203f5848b9"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> grid<a name="class_sampling_1_1_filter_1a9ec9b4fce5574a22db09f2a3c8b2f93a"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> activate ()<a name="class_sampling_1_1_filter_1a8011fcbeb5efeda20bd2dbffbbb70165"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> deactivate ()<a name="class_sampling_1_1_filter_1a8308b4bb6079733f4b77ced9d46da7a9"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> Filter ()<a name="class_sampling_1_1_filter_1ad724ba04cbde6118ceddbd6635e96eaa"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> Filter(<a name="class_sampling_1_1_filter_1a39b9914d0b1a0c54e509d0992facbd4a"></a> const   filteredObject  ,  const   grid  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getFilteredObject ()<a name="class_sampling_1_1_filter_1ae9f51e1d4d767694fc3e192a29ae013e"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getGrid ()<a name="class_sampling_1_1_filter_1a361943c043351a96faa13cfd1f126d27"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Abstract  Constant <br /></td><td> getValueAt(<a name="class_sampling_1_1_filter_1aaf6cee9a80b3085218861a5a8d6b34bc"></a> const   point  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> isActive ()<a name="class_sampling_1_1_filter_1a22761609071413dcce0632885c820e87"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setFilteredObject(<a name="class_sampling_1_1_filter_1a04b347c4d1863fb924237689a0312881"></a> const   obj  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> setGrid(<a name="class_sampling_1_1_filter_1a22a66fdf28522c42f8347161ba1ac3fe"></a> const   grid  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  activate ()<a name="class_sampling_1_1_filter_1a8011fcbeb5efeda20bd2dbffbbb70165"></a><br /></th>
			</tr><tr class="altColor">
				<td> Activates this filter. (if it was already activated, the function call has no effect) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  deactivate ()<a name="class_sampling_1_1_filter_1a8308b4bb6079733f4b77ced9d46da7a9"></a><br /></th>
			</tr><tr class="altColor">
				<td> Deactivates this filter. (if it was already deactivated, the function call has no effect) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Filter ()<a name="class_sampling_1_1_filter_1ad724ba04cbde6118ceddbd6635e96eaa"></a><br /></th>
			</tr><tr class="altColor">
				<td> default c'tor <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Filter(<a name="class_sampling_1_1_filter_1a39b9914d0b1a0c54e509d0992facbd4a"></a> const   filteredObject  ,  const   grid  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with parameters <br /><b> filteredObject: </b> - the sampleable object to be filtered <br /><b> grid: </b> - the grid object that is used by this filter <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getFilteredObject ()<a name="class_sampling_1_1_filter_1ae9f51e1d4d767694fc3e192a29ae013e"></a><br /></th>
			</tr><tr class="altColor">
				<td> Getter function that returns the object to be filtered by this filter. <br /><b> Return:</b> - the sampleable object <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getGrid ()<a name="class_sampling_1_1_filter_1a361943c043351a96faa13cfd1f126d27"></a><br /></th>
			</tr><tr class="altColor">
				<td> Getter function that returns the grid object that is used by this filter. <br /><b> Return:</b> - the pointer of the grid object <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  getValueAt(<a name="class_sampling_1_1_filter_1aaf6cee9a80b3085218861a5a8d6b34bc"></a> const   point  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function (inherited from <a href="#class_sampling_1_1_i_sampleable"> ISampleable</a> ) that calculates the value of the sampleable object at the position specified by the argument 'point'. <br /><b> point: </b> - the point where the object must calculate the return value <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - the value at the given point <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  isActive ()<a name="class_sampling_1_1_filter_1a22761609071413dcce0632885c820e87"></a><br /></th>
			</tr><tr class="altColor">
				<td> Function to query the status of the filter. <br /><b> Return:</b> - true if the filter is activated (and false otherwise) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setFilteredObject(<a name="class_sampling_1_1_filter_1a04b347c4d1863fb924237689a0312881"></a> const   obj  )<br /></th>
			</tr><tr class="altColor">
				<td> Setter function for the object to be filtered. <br /><b> obj: </b> - the new object to be filtered <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setGrid(<a name="class_sampling_1_1_filter_1a22a66fdf28522c42f8347161ba1ac3fe"></a> const   grid  )<br /></th>
			</tr><tr class="altColor">
				<td> Setter function for the grid that will be used by this filter. <br /><b> obj: </b> - the pointer to the new grid object <br /></td>
			</tr>
		</table> <br /><a name="class_sampling_1_1_i_sampleable"></a><h3>
			Class: ISampleable<br />
		</h3><h4>
			Fields<br />
		</h4><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Abstract  Constant <br /></td><td> getValueAt(<a name="class_sampling_1_1_i_sampleable_1aaf6cee9a80b3085218861a5a8d6b34bc"></a> const   point  ,  const   Toperators  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  getValueAt(<a name="class_sampling_1_1_i_sampleable_1aaf6cee9a80b3085218861a5a8d6b34bc"></a> const   point  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function that calculates the value of the sampleable object at the position specified by the argument 'point'. <br /><b> point: </b> - the point where the object must calculate the return value <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - the value at the given point <br /></td>
			</tr>
		</table> <br /><a name="class_sampling_1_1_linear_cube_filter"></a><h3>
			Class: LinearCubeFilter<br />
		</h3><h4>
			Fields<br />
		</h4><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Virtual  Constant <br /></td><td> getValueAt(<a name="class_sampling_1_1_linear_cube_filter_1ae7fe064de3b279d74867a690bd6f4953"></a> const   point  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> LinearCubeFilter ()<a name="class_sampling_1_1_linear_cube_filter_1a4aa2860543819ccb8a3da3df8d845037"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> LinearCubeFilter(<a name="class_sampling_1_1_linear_cube_filter_1a3d2ff46e5e1c56a695e298c7985d4e7b"></a> const   filteredObject  ,  const   grid  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  getValueAt(<a name="class_sampling_1_1_linear_cube_filter_1ae7fe064de3b279d74867a690bd6f4953"></a> const   point  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function (inherited from <a href="#class_sampling_1_1_i_sampleable"> ISampleable</a> ) that calculates the value of the sampleable object at the position specified by the argument 'point'. <br /><b> point: </b> - the point where the object must calculate the return value <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - the value at the given point <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  LinearCubeFilter ()<a name="class_sampling_1_1_linear_cube_filter_1a4aa2860543819ccb8a3da3df8d845037"></a><br /></th>
			</tr><tr class="altColor">
				<td> default c'tor <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  LinearCubeFilter(<a name="class_sampling_1_1_linear_cube_filter_1a3d2ff46e5e1c56a695e298c7985d4e7b"></a> const   filteredObject  ,  const   grid  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with parameters <br /><b> filteredObject: </b> - the sampleable object to be filtered <br /><b> grid: </b> - the grid object that is used by this filter <br /></td>
			</tr>
		</table> <br /><a name="class_sampling_1_1_linear_tetra_filter"></a><h3>
			Class: LinearTetraFilter<br />
		</h3><h4>
			Fields<br />
		</h4><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Virtual  Constant <br /></td><td> getValueAt(<a name="class_sampling_1_1_linear_tetra_filter_1ae7fe064de3b279d74867a690bd6f4953"></a> const   point  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> LinearTetraFilter ()<a name="class_sampling_1_1_linear_tetra_filter_1a5cf0b7a08ecd66f914b411f60d89273f"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> LinearTetraFilter(<a name="class_sampling_1_1_linear_tetra_filter_1a6b06a8935674a42502ffb246a40b7d2f"></a> const   filteredObject  ,  const   grid  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  getValueAt(<a name="class_sampling_1_1_linear_tetra_filter_1ae7fe064de3b279d74867a690bd6f4953"></a> const   point  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function (inherited from <a href="#class_sampling_1_1_i_sampleable"> ISampleable</a> ) that calculates the value of the sampleable object at the position specified by the argument 'point'. <br /><b> point: </b> - the point where the object must calculate the return value <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - the value at the given point <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  LinearTetraFilter ()<a name="class_sampling_1_1_linear_tetra_filter_1a5cf0b7a08ecd66f914b411f60d89273f"></a><br /></th>
			</tr><tr class="altColor">
				<td> default c'tor <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  LinearTetraFilter(<a name="class_sampling_1_1_linear_tetra_filter_1a6b06a8935674a42502ffb246a40b7d2f"></a> const   filteredObject  ,  const   grid  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with parameters <br /><b> filteredObject: </b> - the sampleable object to be filtered <br /><b> grid: </b> - the grid object that is used by this filter <br /></td>
			</tr>
		</table> <br /><a name="class_sampling_1_1_marschner_lobb"></a><h3>
			Class: MarschnerLobb<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> alpha<a name="class_sampling_1_1_marschner_lobb_1a8151e53244827a84261ac958567d57f9"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> f_m<a name="class_sampling_1_1_marschner_lobb_1afae87fa0ea9b525f53166e3b344d1f9b"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getAlpha ()<a name="class_sampling_1_1_marschner_lobb_1a875c34c88467348fca24419daea5b651"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getF_m ()<a name="class_sampling_1_1_marschner_lobb_1afc57668a3818fae77834d221f8f93432"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Virtual  Constant <br /></td><td> getValueAt(<a name="class_sampling_1_1_marschner_lobb_1ae7fe064de3b279d74867a690bd6f4953"></a> const   point  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> MarschnerLobb(<a name="class_sampling_1_1_marschner_lobb_1ab9a9237d3929b45da34ab9eeee080859"></a> const T &  f_m  ,  const T &  alpha  ,  const T &  iso  ,  const   material  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setAlpha(<a name="class_sampling_1_1_marschner_lobb_1a142ba2fa52ae230998a1f72ee25230b1"></a> const T &  alpha  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> setF_m(<a name="class_sampling_1_1_marschner_lobb_1ab4531e807fbe3c07d4f3186575c673bd"></a> const T &  f_m  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getAlpha ()<a name="class_sampling_1_1_marschner_lobb_1a875c34c88467348fca24419daea5b651"></a><br /></th>
			</tr><tr class="altColor">
				<td> This function can return the value of the alpha parameter of the Marschner-Lobb function. <br /><b> Return:</b> - the value of the alpha parameter <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getF_m ()<a name="class_sampling_1_1_marschner_lobb_1afc57668a3818fae77834d221f8f93432"></a><br /></th>
			</tr><tr class="altColor">
				<td> This function can return the value of the f_m parameter of the Marschner-Lobb function. <br /><b> Return:</b> - the value of the f_m parameter <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  getValueAt(<a name="class_sampling_1_1_marschner_lobb_1ae7fe064de3b279d74867a690bd6f4953"></a> const   point  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function that calculates the value of the Marschner-Lobb function at the position specified by the argument 'point'. <br /><b> point: </b> - the point where the object must calculate the return value <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - the value at the given point <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  MarschnerLobb(<a name="class_sampling_1_1_marschner_lobb_1ab9a9237d3929b45da34ab9eeee080859"></a> const T &  f_m  ,  const T &  alpha  ,  const T &  iso  ,  const   material  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /><b> f_m: </b> - the F_m parameter of the Marschner-Lobb volume <br /><b> alpha: </b> - the alpha parameter of the Marschner-Lobb volume <br /><b> iso: </b> - the default albedo value for the volume <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setAlpha(<a name="class_sampling_1_1_marschner_lobb_1a142ba2fa52ae230998a1f72ee25230b1"></a> const T &  alpha  )<br /></th>
			</tr><tr class="altColor">
				<td> This function sets the alpha parameter of the Marschner-Lobb function. <br /><b> -: </b> alpha parameter <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setF_m(<a name="class_sampling_1_1_marschner_lobb_1ab4531e807fbe3c07d4f3186575c673bd"></a> const T &  f_m  )<br /></th>
			</tr><tr class="altColor">
				<td> This function sets the f_m parameter of the Marschner-Lobb function. <br /><b> -: </b> f_m parameter <br /></td>
			</tr>
		</table> <br /><a name="class_sampling_1_1_volume"></a><h3>
			Class: Volume<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> iso<a name="class_sampling_1_1_volume_1a8c8c997c19f49d10d5028ecd6d94805c"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getIso ()<a name="class_sampling_1_1_volume_1af98bbc751e90a15b59c81ee4c17630b2"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Virtual  Constant <br /></td><td> getNormal(<a name="class_sampling_1_1_volume_1af9134066dc508e3201a1dea2acb755a8"></a> Vector  point  ,  const T &  scale  ,  T  value  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Abstract  Constant <br /></td><td> getValueAt(<a name="class_sampling_1_1_volume_1aaf6cee9a80b3085218861a5a8d6b34bc"></a> const   point  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Virtual  Constant <br /></td><td> intersect(<a name="class_sampling_1_1_volume_1aae711dcbf18946964b9c42502e9d3377"></a> const   ray  ,  const   bounds  ,  const T &  scale  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setIso(<a name="class_sampling_1_1_volume_1a06df2552be7fe124a173741e8ba79770"></a> const T &  iso  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> Volume ()<a name="class_sampling_1_1_volume_1a3a8fada6f2d2b5ce58f6a0ffef34d9f1"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> Volume(<a name="class_sampling_1_1_volume_1aefc1e3fc5f3846e8a1f3186e06017b52"></a> const T &  iso  ,  const   material  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getIso ()<a name="class_sampling_1_1_volume_1af98bbc751e90a15b59c81ee4c17630b2"></a><br /></th>
			</tr><tr class="altColor">
				<td> Getter function for the albedo value for the volume. <br /><b> Return:</b> - the albedo value for the volume <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  getNormal(<a name="class_sampling_1_1_volume_1af9134066dc508e3201a1dea2acb755a8"></a> Vector  point  ,  const T &  scale  ,  T  value  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function that can approximate a normal vector to the surface at a given point. <br /><b> point: </b> - the point whose normal vector we are interested <br /><b> scale: </b> - the scale parameter defines the distance from point in each dimension to build the gradient vector <br /><b> value: </b> - the value at the point won't be recomputed, if it's given in this parameter <br /><b> Toperators: </b> - the operators object of type T <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  getValueAt(<a name="class_sampling_1_1_volume_1aaf6cee9a80b3085218861a5a8d6b34bc"></a> const   point  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function that calculates the value of the sampleable object at the position specified by the argument 'point'. <br /><b> point: </b> - the point where the object must calculate the return value <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - the value at the given point <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  intersect(<a name="class_sampling_1_1_volume_1aae711dcbf18946964b9c42502e9d3377"></a> const   ray  ,  const   bounds  ,  const T &  scale  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function that implements the intersection with the concrete object. If no intersection was found, it will return an empty Vector. (0D Vector) <br /><b> ray: </b> - the intersection ray <br /><b> bounds: </b> - the bounds between the intersection will be looked for <br /><b> scale: </b> - scale used by ray casting algorithms <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - The collection of intersections in ascending order of dimension time. <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setIso(<a name="class_sampling_1_1_volume_1a06df2552be7fe124a173741e8ba79770"></a> const T &  iso  )<br /></th>
			</tr><tr class="altColor">
				<td> Setter function for the albedo value for the volume. <br /><b> iso: </b> - the new albedo value for the volume <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Protected  Volume ()<a name="class_sampling_1_1_volume_1a3a8fada6f2d2b5ce58f6a0ffef34d9f1"></a><br /></th>
			</tr><tr class="altColor">
				<td> default c'tor <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Protected  Volume(<a name="class_sampling_1_1_volume_1aefc1e3fc5f3846e8a1f3186e06017b52"></a> const T &  iso  ,  const   material  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with argument <br /><b> iso: </b> - the albedo value for the volume <br /><b> material: </b> - the material of the isosurfaces of the volume (given for visualisation purposes) <br /></td>
			</tr>
		</table> <br /><a name="namespace_utilities"></a><h2>
			Namespace: Utilities<br />
		</h2><a name="class_utilities_1_1_float_operators"></a><h3>
			Class: FloatOperators<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Private <br /></td><td> EPS<a name="class_utilities_1_1_float_operators_1a8699e9cea9e8bd0b1b3a3bb7d6cf671c"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Virtual  Constant <br /></td><td> equals(<a name="class_utilities_1_1_float_operators_1a3634d4c6fb482cced6a9e29784185b82"></a> const float &  num1  ,  const float &  num2  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> FloatOperators(<a name="class_utilities_1_1_float_operators_1a3e605251b6520f5962e85bb4e2f6f97d"></a> float  eps  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  equals(<a name="class_utilities_1_1_float_operators_1a3634d4c6fb482cced6a9e29784185b82"></a> const float &  num1  ,  const float &  num2  )<br /></th>
			</tr><tr class="altColor">
				<td> Method exams if the objects are equal or not. <br /><b> num1: </b> - the first float number <br /><b> num2: </b> - the second float number <br /><b> Return:</b> - true if the two numbers are equal (and false otherwise) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  FloatOperators(<a name="class_utilities_1_1_float_operators_1a3e605251b6520f5962e85bb4e2f6f97d"></a> float  eps  )<br /></th>
			</tr><tr class="altColor">
				<td> default c'tor <br /><b> eps: </b> - epsilon value for the equality check <br /></td>
			</tr>
		</table> <br /><a name="class_utilities_1_1_type_operators"></a><h3>
			Class: TypeOperators<br />
		</h3><h4>
			Fields<br />
		</h4><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Virtual  Constant <br /></td><td> abs(<a name="class_utilities_1_1_type_operators_1a568333198beb5cf8b2b822ed1f517586"></a> const T &  obj  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Virtual  Constant <br /></td><td> castToInt(<a name="class_utilities_1_1_type_operators_1a326e5fe91b362795523b3b705ddd3abe"></a> const T &  obj  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Virtual  Constant <br /></td><td> equals(<a name="class_utilities_1_1_type_operators_1a01f8ffb315882112eded9817279c652c"></a> const T &  obj1  ,  const T &  obj2  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Virtual  Constant <br /></td><td> greaterThan(<a name="class_utilities_1_1_type_operators_1ac0c4e4d72daedaf61ac5b3f10832abc2"></a> const T &  obj1  ,  const T &  obj2  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Virtual  Constant <br /></td><td> greaterThanOrEquals(<a name="class_utilities_1_1_type_operators_1a01d0fde7f2eb384eadefd35abadf5b12"></a> const T &  obj1  ,  const T &  obj2  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  abs(<a name="class_utilities_1_1_type_operators_1a568333198beb5cf8b2b822ed1f517586"></a> const T &  obj  )<br /></th>
			</tr><tr class="altColor">
				<td> Method returns the absolute value of the object. <br /><b> obj: </b> - the object whose absolute value we are looking for <br /><b> Return:</b> - the absolute value of the object <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  castToInt(<a name="class_utilities_1_1_type_operators_1a326e5fe91b362795523b3b705ddd3abe"></a> const T &  obj  )<br /></th>
			</tr><tr class="altColor">
				<td> Method casts an object of type T to an integer value. <br /><b> obj: </b> - the object to be casted <br /><b> Return:</b> - an integer representation of the object <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  equals(<a name="class_utilities_1_1_type_operators_1a01f8ffb315882112eded9817279c652c"></a> const T &  obj1  ,  const T &  obj2  )<br /></th>
			</tr><tr class="altColor">
				<td> Method exams if the objects are equal or not. <br /><b> obj1: </b> - the first object <br /><b> obj2: </b> - the second object <br /><b> Return:</b> - true if the two objects are equal (and false otherwise) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  greaterThan(<a name="class_utilities_1_1_type_operators_1ac0c4e4d72daedaf61ac5b3f10832abc2"></a> const T &  obj1  ,  const T &  obj2  )<br /></th>
			</tr><tr class="altColor">
				<td> Method exams if the first object is greater than the second. <br /><b> obj1: </b> - the first object <br /><b> obj2: </b> - the second object <br /><b> Return:</b> - true if the first object is greater than the second (and false otherwise) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  greaterThanOrEquals(<a name="class_utilities_1_1_type_operators_1a01d0fde7f2eb384eadefd35abadf5b12"></a> const T &  obj1  ,  const T &  obj2  )<br /></th>
			</tr><tr class="altColor">
				<td> Method exams if the first object is greater than the second or they are equal. <br /><b> obj1: </b> - the first object <br /><b> obj2: </b> - the second object <br /><b> Return:</b> - true if the first object is greater than the second or they are equal (and false otherwise) <br /></td>
			</tr>
		</table> <br /><a name="namespace_visualisation"></a><h2>
			Namespace: Visualisation<br />
		</h2><a name="class_visualisation_1_1_camera"></a><h3>
			Class: Camera<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> imgPlane<a name="class_visualisation_1_1_camera_1a591242bd411b6edc95230b4a50fe29e4"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> position<a name="class_visualisation_1_1_camera_1a92c08fdee4c3d7ce4f5180f6222a9a13"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> scale<a name="class_visualisation_1_1_camera_1ac643790c550721659e9c65657a946b64"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> target<a name="class_visualisation_1_1_camera_1a638612f355e51566db942352b3d766d3"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> u<a name="class_visualisation_1_1_camera_1a45950d62903c61035ae44d3369fa4de6"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> up<a name="class_visualisation_1_1_camera_1ab9a868c542948837e7c480136ef607a5"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> v<a name="class_visualisation_1_1_camera_1a085dcb77f34a3b67855b945b67193e58"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> w<a name="class_visualisation_1_1_camera_1abe195e06d9db73b3a48108de43801417"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> Camera(<a name="class_visualisation_1_1_camera_1a198510be904c62692e946888a55669b3"></a> const   position  ,  const   target  ,  const   up  ,  const   imgPlane  ,  const T &  scale  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> capture(<a name="class_visualisation_1_1_camera_1ae82c208ee6495d11bd3055cf4db8772a"></a> const   modelSpace  ,  Colour  imgBuffer  ,  unsigned short  hRes  ,  unsigned short  vRes  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Private  Constant <br /></td><td> get3DcrossProd(<a name="class_visualisation_1_1_camera_1afd68152de8c52b9e3f0459c413463b0a"></a> const   u  ,  const   v  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getImagePlane ()<a name="class_visualisation_1_1_camera_1ab7e8c42e2bf86d647287a4f03d91795f"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getPosition ()<a name="class_visualisation_1_1_camera_1aec0f566b4f80ad1f6bdffabd00fc1c53"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getScale ()<a name="class_visualisation_1_1_camera_1a85e8606eebf3cfd76af7d5ec308152d9"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getTarget ()<a name="class_visualisation_1_1_camera_1a82febe46be55b809f39c09023e9a94fd"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getUpVector ()<a name="class_visualisation_1_1_camera_1a5ce9a3efd30b5f99eea7abc32b7f5030"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setImagePlane(<a name="class_visualisation_1_1_camera_1ac59fe71c978d3683f22cbbe25b88fdee"></a> const   imgPlane  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> setPosition(<a name="class_visualisation_1_1_camera_1acceeea5f3e89935b9ec259a0d6f78020"></a> const   position  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setScale(<a name="class_visualisation_1_1_camera_1afebb878e948e05d2913a0ec13b9f8b17"></a> const T &  scale  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> setTarget(<a name="class_visualisation_1_1_camera_1a48faa2830f1ed31f63d0bfb714204279"></a> const   target  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setUpVector(<a name="class_visualisation_1_1_camera_1a7156609219c613e7971fe173d09584b4"></a> const   up  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Private <br /></td><td> updateCoSys ()<a name="class_visualisation_1_1_camera_1ad7490e67730ec1c91c70618adc0124d3"></a><br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Camera(<a name="class_visualisation_1_1_camera_1a198510be904c62692e946888a55669b3"></a> const   position  ,  const   target  ,  const   up  ,  const   imgPlane  ,  const T &  scale  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  capture(<a name="class_visualisation_1_1_camera_1ae82c208ee6495d11bd3055cf4db8772a"></a> const   modelSpace  ,  Colour  imgBuffer  ,  unsigned short  hRes  ,  unsigned short  vRes  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Method, that creates an image of the model space from the cameras view with the given resolution. <br /><b> modelSpace: </b> - the model space to be captured <br /><b> imgBuffer: </b> - array where to store the image color values <br /><b> hRes: </b> - the horizontal resolution of the image <br /><b> vRes: </b> - the vertical resolution of the image <br /><b> Toperators: </b> - the operators object of type T <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - the number of colour values put in the image buffer <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Private  Constant  get3DcrossProd(<a name="class_visualisation_1_1_camera_1afd68152de8c52b9e3f0459c413463b0a"></a> const   u  ,  const   v  )<br /></th>
			</tr><tr class="altColor">
				<td> Cross product for 3D vectors. <br /><b> u: </b><br /><b> v: </b> - the two 3D vectors whose cross product we are looking for <br /><b> Return:</b> - u x v <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getImagePlane ()<a name="class_visualisation_1_1_camera_1ab7e8c42e2bf86d647287a4f03d91795f"></a><br /></th>
			</tr><tr class="altColor">
				<td> Getter function for the image plane object. <br /><b> Return:</b> - the actual image plane object <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getPosition ()<a name="class_visualisation_1_1_camera_1aec0f566b4f80ad1f6bdffabd00fc1c53"></a><br /></th>
			</tr><tr class="altColor">
				<td> Getter function for the position of the camera. <br /><b> Return:</b> - the actual position of the camera <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getScale ()<a name="class_visualisation_1_1_camera_1a85e8606eebf3cfd76af7d5ec308152d9"></a><br /></th>
			</tr><tr class="altColor">
				<td> Getter function for the scale value. This value is used by the ray casting algorithm. <br /><b> Return:</b> - the actual scale value <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getTarget ()<a name="class_visualisation_1_1_camera_1a82febe46be55b809f39c09023e9a94fd"></a><br /></th>
			</tr><tr class="altColor">
				<td> Getter function for the target of the camera. <br /><b> Return:</b> - the actual target point of the camera <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getUpVector ()<a name="class_visualisation_1_1_camera_1a5ce9a3efd30b5f99eea7abc32b7f5030"></a><br /></th>
			</tr><tr class="altColor">
				<td> Getter function for the UP-vector of the camera. <br /><b> Return:</b> - the actual UP-vector of the camera <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setImagePlane(<a name="class_visualisation_1_1_camera_1ac59fe71c978d3683f22cbbe25b88fdee"></a> const   imgPlane  )<br /></th>
			</tr><tr class="altColor">
				<td> Setter function for the image plane object. <br /><b> imgPlane: </b> - the new image plane object <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setPosition(<a name="class_visualisation_1_1_camera_1acceeea5f3e89935b9ec259a0d6f78020"></a> const   position  )<br /></th>
			</tr><tr class="altColor">
				<td> Setter function for the position of the camera. <br /><b> position: </b> - the new position of the camera <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setScale(<a name="class_visualisation_1_1_camera_1afebb878e948e05d2913a0ec13b9f8b17"></a> const T &  scale  )<br /></th>
			</tr><tr class="altColor">
				<td> Setter function for the scale value. This value is used by the ray casting algorithm. <br /><b> imgPlane: </b> - the new scale value <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setTarget(<a name="class_visualisation_1_1_camera_1a48faa2830f1ed31f63d0bfb714204279"></a> const   target  )<br /></th>
			</tr><tr class="altColor">
				<td> Setter function for the target of the camera. <br /><b> position: </b> - the new target point of the camera <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setUpVector(<a name="class_visualisation_1_1_camera_1a7156609219c613e7971fe173d09584b4"></a> const   up  )<br /></th>
			</tr><tr class="altColor">
				<td> Setter function for the UP-vector of the camera. <br /><b> up: </b> - the new UP-vector of the camera <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Private  updateCoSys ()<a name="class_visualisation_1_1_camera_1ad7490e67730ec1c91c70618adc0124d3"></a><br /></th>
			</tr><tr class="altColor">
				<td> This method updates the coordinate system vectors according to the other vectors. (position, target, up) <br /></td>
			</tr>
		</table> <br /><a name="struct_visualisation_1_1_colour"></a><h3>
			Struct: Colour<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> a<a name="struct_visualisation_1_1_colour_1a24420a9beaac7cee08b5e255a4c29db1"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> b<a name="struct_visualisation_1_1_colour_1a41cede1b4c0d05cff170ad5761f70964"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> g<a name="struct_visualisation_1_1_colour_1a83576af39a9f289a28c1263d61073508"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> r<a name="struct_visualisation_1_1_colour_1afd7b1ea9ff115205b65e0bffc92946ac"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> Colour ()<a name="struct_visualisation_1_1_colour_1ae3eec6b1fc1ffafd6e3f907fa9590fdf"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> Colour(<a name="struct_visualisation_1_1_colour_1a214e2f82e282989afe4549a07d7d0041"></a> unsigned char  r  ,  unsigned char  g  ,  unsigned char  b  ,  unsigned char  a  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Colour ()<a name="struct_visualisation_1_1_colour_1ae3eec6b1fc1ffafd6e3f907fa9590fdf"></a><br /></th>
			</tr><tr class="altColor">
				<td> default c'tor <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Colour(<a name="struct_visualisation_1_1_colour_1a214e2f82e282989afe4549a07d7d0041"></a> unsigned char  r  ,  unsigned char  g  ,  unsigned char  b  ,  unsigned char  a  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /></td>
			</tr>
		</table> <br /><a name="struct_visualisation_1_1_image_plane"></a><h3>
			Struct: ImagePlane<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> b<a name="struct_visualisation_1_1_image_plane_1adab634951eeadcd5a7c8840eefbf780f"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> d<a name="struct_visualisation_1_1_image_plane_1a6b27b78b9d187dd926ec53a122ad2772"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> l<a name="struct_visualisation_1_1_image_plane_1a4171bf52fa856bad220dc1111bda1ec5"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> r<a name="struct_visualisation_1_1_image_plane_1a3ff0123200292ec4b7e3e6319d048fa0"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> t<a name="struct_visualisation_1_1_image_plane_1aa8888ec579d37bf1b17d7d5bee3b76c1"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> ImagePlane ()<a name="struct_visualisation_1_1_image_plane_1a560a456ce61b8a24222b7f32e309a9e4"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> ImagePlane(<a name="struct_visualisation_1_1_image_plane_1ae2ef05c4c2b24b984ed6043a76d32c4c"></a> const T &  d  ,  const T &  l  ,  const T &  r  ,  const T &  b  ,  const T &  t  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  ImagePlane ()<a name="struct_visualisation_1_1_image_plane_1a560a456ce61b8a24222b7f32e309a9e4"></a><br /></th>
			</tr><tr class="altColor">
				<td> default c'tor <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  ImagePlane(<a name="struct_visualisation_1_1_image_plane_1ae2ef05c4c2b24b984ed6043a76d32c4c"></a> const T &  d  ,  const T &  l  ,  const T &  r  ,  const T &  b  ,  const T &  t  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /></td>
			</tr>
		</table> <br /><a name="class_visualisation_1_1_light"></a><h3>
			Class: Light<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Protected <br /></td><td> intensity<a name="class_visualisation_1_1_light_1a698096589cf2bca9181d8eb166dc9852"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Protected <br /></td><td> position<a name="class_visualisation_1_1_light_1a92c08fdee4c3d7ce4f5180f6222a9a13"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getIntensity ()<a name="class_visualisation_1_1_light_1ad42cb93f510686e71c32973cba0c3fc3"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getPosition ()<a name="class_visualisation_1_1_light_1aec0f566b4f80ad1f6bdffabd00fc1c53"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> Light ()<a name="class_visualisation_1_1_light_1a7f8a7be05225f470c200f7e4ff914a3c"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> Light(<a name="class_visualisation_1_1_light_1ac091eb6e677551efd41b02b4839396f3"></a> const   position  ,  const   intensity  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setIntensity(<a name="class_visualisation_1_1_light_1a480aa666a77426e1db03b5f310c2d91d"></a> const   intensity  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> setPosition(<a name="class_visualisation_1_1_light_1acceeea5f3e89935b9ec259a0d6f78020"></a> const   position  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getIntensity ()<a name="class_visualisation_1_1_light_1ad42cb93f510686e71c32973cba0c3fc3"></a><br /></th>
			</tr><tr class="altColor">
				<td> Get the intensity of the lightsource. <br /><b> Return:</b> - the intensity of the lightsource (for each wavelength) <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getPosition ()<a name="class_visualisation_1_1_light_1aec0f566b4f80ad1f6bdffabd00fc1c53"></a><br /></th>
			</tr><tr class="altColor">
				<td> Get the position of the lightsource. <br /><b> Return:</b> - the position of the lightsource <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Light ()<a name="class_visualisation_1_1_light_1a7f8a7be05225f470c200f7e4ff914a3c"></a><br /></th>
			</tr><tr class="altColor">
				<td> default c'tor <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Light(<a name="class_visualisation_1_1_light_1ac091eb6e677551efd41b02b4839396f3"></a> const   position  ,  const   intensity  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setIntensity(<a name="class_visualisation_1_1_light_1a480aa666a77426e1db03b5f310c2d91d"></a> const   intensity  )<br /></th>
			</tr><tr class="altColor">
				<td> Set the intensity of the lightsource. <br /><b> intensity: </b> - the new intensity of the lightsource <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setPosition(<a name="class_visualisation_1_1_light_1acceeea5f3e89935b9ec259a0d6f78020"></a> const   position  )<br /></th>
			</tr><tr class="altColor">
				<td> Set the position of the lightsource. <br /><b> position: </b> - the new position of the lightsource <br /></td>
			</tr>
		</table> <br /><a name="struct_visualisation_1_1_material"></a><h3>
			Struct: Material<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> ka<a name="struct_visualisation_1_1_material_1adcbbb333b6d941fddfe1ea6143fa5762"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> kd<a name="struct_visualisation_1_1_material_1ac5454dea13fcc74f22cabb7c3278be55"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> ks<a name="struct_visualisation_1_1_material_1a4d9761d66c65f3bcf95f37685c771d0c"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> n<a name="struct_visualisation_1_1_material_1ab46d5dac624eb0e9a38071be6291cdb2"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> opacity<a name="struct_visualisation_1_1_material_1a18bec5279be0e082ea275e09fe43e4ad"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> Material(<a name="struct_visualisation_1_1_material_1a59ff61970c48a0fa575db309b6b37019"></a> const   ka  ,  const   kd  ,  const   ks  ,  const float &  n  ,  const float &  opacity  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Material(<a name="struct_visualisation_1_1_material_1a59ff61970c48a0fa575db309b6b37019"></a> const   ka  ,  const   kd  ,  const   ks  ,  const float &  n  ,  const float &  opacity  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /></td>
			</tr>
		</table> <br /><a name="class_visualisation_1_1_model_space"></a><h3>
			Class: ModelSpace<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Private <br /></td><td> background<a name="class_visualisation_1_1_model_space_1abc6e2c1f7d2f83aa02d907c3c85710c0"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Private <br /></td><td> boundingVolume<a name="class_visualisation_1_1_model_space_1ac1d2c45b52e431ada0adde7b95eac059"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Private <br /></td><td> lights<a name="class_visualisation_1_1_model_space_1a45a3f05f5ff0687bb6ba389724d41ef9"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Private <br /></td><td> objects<a name="class_visualisation_1_1_model_space_1aab24e9770b54bf3548269441a2f2eafc"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Private <br /></td><td> shader<a name="class_visualisation_1_1_model_space_1a173b9e85c52489539a689101b1ea9247"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> addLight(<a name="class_visualisation_1_1_model_space_1a4c60888619e96eb8ca8fb827a84e4a8a"></a> const   light  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> addObject(<a name="class_visualisation_1_1_model_space_1a33ce733b69b82b6c7cad50fcc752525b"></a> const   object  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getBackground ()<a name="class_visualisation_1_1_model_space_1a03709018d9b4886b872d175c84d63adf"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getBoundingVolume ()<a name="class_visualisation_1_1_model_space_1a02ddc295ff120ba5fa6caadb5b37ca91"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getColour(<a name="class_visualisation_1_1_model_space_1ab3ae80917c1e3a8b2437cbc57e9c127c"></a> const   ray  ,  const T &  scale  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getNearestIntersection(<a name="class_visualisation_1_1_model_space_1a924ee2653f2843f730b92e8244438ffc"></a> const   ray  ,  const T &  scale  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getShader ()<a name="class_visualisation_1_1_model_space_1ab0a6a2215f518afb33ecbfca57d8ffec"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> ModelSpace(<a name="class_visualisation_1_1_model_space_1a088282228a2426627fabcc145a296b73"></a> const   boundingVolume  ,  const   shader  ,  const   background  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> removeLight(<a name="class_visualisation_1_1_model_space_1a9a49141300bb2c66206f83c1d068fcec"></a> const   light  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> removeObject(<a name="class_visualisation_1_1_model_space_1ad2da63fc69909a91b630b11725871c35"></a> const   object  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setBackground(<a name="class_visualisation_1_1_model_space_1a463e339c2b252e70ff31456a2c243cf8"></a> const   background  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> setBoundingVolume(<a name="class_visualisation_1_1_model_space_1aa75c43188ef6676e58dacc411d36afda"></a> const   boundingVolume  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> setShader(<a name="class_visualisation_1_1_model_space_1a12ef60c4d01229b52f7450cccdef4484"></a> const   shader  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  addLight(<a name="class_visualisation_1_1_model_space_1a4c60888619e96eb8ca8fb827a84e4a8a"></a> const   light  )<br /></th>
			</tr><tr class="altColor">
				<td> Locate a new lightsource in the model space. <br /><b> light: </b> - the new lightsource to be located <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  addObject(<a name="class_visualisation_1_1_model_space_1a33ce733b69b82b6c7cad50fcc752525b"></a> const   object  )<br /></th>
			</tr><tr class="altColor">
				<td> Locate a new object in the model space. <br /><b> object: </b> - the new object to be located <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getBackground ()<a name="class_visualisation_1_1_model_space_1a03709018d9b4886b872d175c84d63adf"></a><br /></th>
			</tr><tr class="altColor">
				<td> Getter method for the background colour. <br /><b> Return:</b> - the used background colour <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getBoundingVolume ()<a name="class_visualisation_1_1_model_space_1a02ddc295ff120ba5fa6caadb5b37ca91"></a><br /></th>
			</tr><tr class="altColor">
				<td> Getter method for the bounding volume. <br /><b> Return:</b> - the used bounding volume <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getColour(<a name="class_visualisation_1_1_model_space_1ab3ae80917c1e3a8b2437cbc57e9c127c"></a> const   ray  ,  const T &  scale  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Do the ray tracing and shading for the given ray. <br /><b> ray: </b> - the ray to be traced or casted <br /><b> scale: </b> - the scale value used by the ray casting algorithm <br /><b> Toperators: </b> - the operators object of type T <br /><b> Return:</b> - the colour value in the model space for this ray <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getNearestIntersection(<a name="class_visualisation_1_1_model_space_1a924ee2653f2843f730b92e8244438ffc"></a> const   ray  ,  const T &  scale  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> This function returns the informations about the intersection with the nearest object in the ray direction in the model space. <br /><b> ray: </b> - the ray to be traced or casted <br /><b> scale: </b> - the scale value used by the ray casting algorithm <br /><b> Return:</b> - the intersection object of the nearest intersection <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Constant  getShader ()<a name="class_visualisation_1_1_model_space_1ab0a6a2215f518afb33ecbfca57d8ffec"></a><br /></th>
			</tr><tr class="altColor">
				<td> Getter method for the shader object. <br /><b> Return:</b> - the used shader object <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  ModelSpace(<a name="class_visualisation_1_1_model_space_1a088282228a2426627fabcc145a296b73"></a> const   boundingVolume  ,  const   shader  ,  const   background  )<br /></th>
			</tr><tr class="altColor">
				<td> c'tor with arguments <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  removeLight(<a name="class_visualisation_1_1_model_space_1a9a49141300bb2c66206f83c1d068fcec"></a> const   light  )<br /></th>
			</tr><tr class="altColor">
				<td> Remove a lightsource from the model space. <br /><b> light: </b> - the lightsource to be removed <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  removeObject(<a name="class_visualisation_1_1_model_space_1ad2da63fc69909a91b630b11725871c35"></a> const   object  )<br /></th>
			</tr><tr class="altColor">
				<td> Remove an object from the model space. <br /><b> object: </b> - the object to be removed <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setBackground(<a name="class_visualisation_1_1_model_space_1a463e339c2b252e70ff31456a2c243cf8"></a> const   background  )<br /></th>
			</tr><tr class="altColor">
				<td> Setter method for the background colour. <br /><b> shader: </b> - the new background colour <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setBoundingVolume(<a name="class_visualisation_1_1_model_space_1aa75c43188ef6676e58dacc411d36afda"></a> const   boundingVolume  )<br /></th>
			</tr><tr class="altColor">
				<td> Setter method for the bounding volume. <br /><b> boundingVolume: </b> - the new bounding volume object <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  setShader(<a name="class_visualisation_1_1_model_space_1a12ef60c4d01229b52f7450cccdef4484"></a> const   shader  )<br /></th>
			</tr><tr class="altColor">
				<td> Setter method for the shader object. <br /><b> shader: </b> - the new shader object <br /></td>
			</tr>
		</table> <br /><a name="class_visualisation_1_1_phong_shader"></a><h3>
			Class: PhongShader<br />
		</h3><h4>
			Fields<br />
		</h4><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> PhongShader ()<a name="class_visualisation_1_1_phong_shader_1ad60de4da2e8379b5daf6c05a8dd25c8d"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Virtual  Constant <br /></td><td> shade(<a name="class_visualisation_1_1_phong_shader_1a973bb877dced2645518b16cc3241fced"></a> const   material  ,  const   light  ,  Vector  N  ,  Vector  L  ,  Vector  V  ,  const   Toperators  )<br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  PhongShader ()<a name="class_visualisation_1_1_phong_shader_1ad60de4da2e8379b5daf6c05a8dd25c8d"></a><br /></th>
			</tr><tr class="altColor">
				<td> default c'tor <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Virtual  Constant  shade(<a name="class_visualisation_1_1_phong_shader_1a973bb877dced2645518b16cc3241fced"></a> const   material  ,  const   light  ,  Vector  N  ,  Vector  L  ,  Vector  V  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function that computes the intensity values for each colour channels according to the given parameters. <br /><b> material: </b> - the material of the surface <br /><b> light: </b> - the lightsource <br /><b> N: </b> - normal of the surface <br /><b> L: </b> - negative light direction <br /><b> V: </b> - negative ray direction <br /><b> Return:</b> - the intensity values for each colour channel <br /></td>
			</tr>
		</table> <br /><a name="class_visualisation_1_1_shader"></a><h3>
			Class: Shader<br />
		</h3><h4>
			Fields<br />
		</h4><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Abstract  Constant <br /></td><td> shade(<a name="class_visualisation_1_1_shader_1ad743e07f30c285dc43ee6cda2b98eb75"></a> const   material  ,  const   light  ,  Vector  N  ,  Vector  L  ,  Vector  V  ,  const   Toperators  )<br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> Shader ()<a name="class_visualisation_1_1_shader_1ab5852b47125ce80509f0341cf1bd1f96"></a><br /><br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Abstract  Constant  shade(<a name="class_visualisation_1_1_shader_1ad743e07f30c285dc43ee6cda2b98eb75"></a> const   material  ,  const   light  ,  Vector  N  ,  Vector  L  ,  Vector  V  ,  const   Toperators  )<br /></th>
			</tr><tr class="altColor">
				<td> Function that computes the intensity values for each colour channels according to the given parameters. <br /><b> material: </b> - the material of the surface <br /><b> light: </b> - the lightsource <br /><b> N: </b> - normal of the surface <br /><b> L: </b> - negative light direction <br /><b> V: </b> - negative ray direction <br /><b> Return:</b> - the intensity values for each colour channel <br /></td>
			</tr>
		</table> <br /><table style="width:70%">
			<tr class="rowColor">
				<th> Public  Shader ()<a name="class_visualisation_1_1_shader_1ab5852b47125ce80509f0341cf1bd1f96"></a><br /></th>
			</tr><tr class="altColor">
				<td> default c'tor <br /></td>
			</tr>
		</table> <br /><a name="class_visualisation_1_1_t_g_a_image"></a><h3>
			Class: TGAImage<br />
		</h3><h4>
			Fields<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Private <br /></td><td> m_height<a name="class_visualisation_1_1_t_g_a_image_1ade8e56e449b6337d0794a6994b27395a"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Private <br /></td><td> m_pixels<a name="class_visualisation_1_1_t_g_a_image_1a501eb86d8677346bc988dcc36523491d"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Private <br /></td><td> m_width<a name="class_visualisation_1_1_t_g_a_image_1a7e8a40a7e7648acab842f66741a5b9cb"></a><br /><br /></td>
			</tr>
		</table><h4>
			Properties<br />
		</h4><h4>
			Methods<br />
		</h4><table style="width:70%">
			<tr class="rowColor">
				<th>  <br /></th><th> Name and Description<br /></th>
			</tr><tr class="altColor">
				<td> Public  Constant <br /></td><td> getHeight ()<a name="class_visualisation_1_1_t_g_a_image_1a02f835c0692e2e99f24589cd67513a31"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public  Constant <br /></td><td> getWidth ()<a name="class_visualisation_1_1_t_g_a_image_1a459348d235f3f750337868d4eb1cccff"></a><br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> TGAImage ()<a name="class_visualisation_1_1_t_g_a_image_1abccaad377e51a135b1d503b741f5a423"></a><br /><br /></td>
			</tr><tr class="rowColor">
				<td> Public <br /></td><td> TGAImage(<a name="class_visualisation_1_1_t_g_a_image_1a2ea3e73b8827d9801ceba3b4f660605b"></a> const   pixels  ,  short  width  ,  short  height  )<br /><br /></td>
			</tr><tr class="altColor">
				<td> Public <br /></td><td> WriteImage(<a name="class_visualisation_1_1_t_g_a_image_1a0a81640808e5f881d8eca703459781a6"></a> const string &  filename  )<br /><br /></td>
			</tr>
		</table> <br />
	</body>
</html>